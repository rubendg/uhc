%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is main body 'main'?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore).mainUseExists
SEM AGItf
  | AGItf       loc         .   mainUseExists
                                            =   case @expr.letTCBody of
                                                  Expr_Var n | n == hsnMain -> True
                                                  _                          -> False
                            .   insertMainUse
                                            =   not @mainUseExists
%%]

%%[(5020 codegen coresysf tycore)
SEM AGItf
  | AGItf       loc         .   insertMainUse
                                            :=  not @mainUseExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Does a binding for main exist?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore).mainDefExists
SEM AGItf
  | AGItf       loc         .   mainDefExists
                                            =   let ds = [ b | (_,g) <- @expr.letValBindL, b <- g, C.valBindNm b == hsnMain ]
                                                in  not (null ds)
                            .   insertMainDef
                                            =   not @mainDefExists
%%]

%%[(5020 codegen coresysf tycore)
SEM AGItf
  | AGItf       loc         .   insertMainDef
                                            :=  not @mainDefExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore) hs
ctyLookup :: VarMp -> TyKiGam -> HsName -> ValGam -> C.Ty
ctyLookup tyVarMp tkg nm g = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi tkg) $ (tyVarMp `varUpd`) $ fst $ valGamLookupTy nm g

ctyFromTy :: TyKiGam -> VarMp -> Ty -> C.Ty
ctyFromTy tkg m t = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi tkg) (m `varUpd` t)

ctyBareFromTy :: VarMp -> Ty -> C.Ty
ctyBareFromTy m t = C.tyToTyCoreBare (m `varUpd` t)
%%]

%%[(8 codegen coresysf tycore) hs
ctyCloseExists :: C.Ty -> (C.Ty,C.Expr -> C.Expr)
ctyCloseExists t
  = case C.unTySeq t of
      (C.Expr_Exists s te) -> (te,C.Expr_CloseExists (C.tyL0BindToL1Bind s) (C.tyErr "ctyCloseExists.tyClosed") t)
      _                    -> (t ,id)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: down passing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AllExpr AllPatExpr AllCase [ ctyTopDown: {C.Ty} | | ]
ATTR AllCase [ ctyPatTopDown: {C.Ty} | | ]

SEM Expr
  | IConst      loc         .   cty         =   C.tyInt
  | CConst      loc         .   cty         =   C.tyChar
  | Var Con     loc         .   cty         =   ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @ty_g_
  | Lam         
%%[[12
    LamImpl
%%]]
                loc         .   ctyTopDownArgBase
                                            =   cSubstApp @tcSubstLamSpine @ctyLamArg
                            .   ctyTopDownResBase
                                            =   cSubstApp @tcSubstLamSpine @ctyLamRes
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   ctyTopDownArgBase
                                            =   cSubstApp @func.tcSubstAppSpine $ C.tyUnThunkTySeq $ C.unTySeq @ctyAppArg
                loc         .   cty         =   @ctyTyAppRes
  | * - Var Con IConst CConst App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   cty         =   @lhs.ctyTopDown

SEM PatExpr
  | AppTop Rec  loc         .   ctyPat      =   C.mkTySeq $ ctyFromTy @lhs.finTyKiGam emptyVarMp @finKnPatTy -- @lhs.finTyVarMp @knPatTy

SEM PatExpr
  | Var         loc         .   cty         =   @lhs.ctyTopDown
  | AppTop      loc         .   cty         =   C.mkTyThunk @ctyPat

SEM Decl
  | Val         loc         .   cty         =   ctyLookup @lhs.finTyVarMp @lhs.finTyKiGam @patExpr.topNm @lhs.finValGam
                            .   ctyBind     =   if @lhs.isStrict then @cty else C.mkTyThunk @cty
  | Data        loc         .   cki         =   C.tyToTyCoreKi $ @lhs.finKiVarMp `varUpd` tkgiKi @dataTkgi -- $ tkgiKi $ fst $ tyKiGamLookupByNameErr @tyNm @lhs.finTyKiGam
%%]

%%[(8 codegen coresysf tycore)
SEM AGItf
  | AGItf       expr        .   ctyTopDown  =   C.tyErr "AGItf.AGItf.ctyTopDown"

SEM Expr
  | Lam         
%%[[12
    LamImpl
%%]]
                arg         .   ctyTopDown  =   @ctyTopDownArgBase
                (body.ctyTopDown,loc.closeExistsWrap)
                                            =   ctyCloseExists @ctyTopDownResBase
  | Case        alts        .   ctyPatTopDown
                                            =   @expr.ctyBotUp
  | App AppImpred
%%[[12
    AppImpl
%%]]
                arg         .   ctyTopDown  =   @ctyTopDownArgBase

SEM Decl
  | Val         loc         .   ctyTopDown  =   C.tyUnThunkTySeq @ctyBind

SEM PatExpr
  | App         arg         .   ctyTopDown  =   cSubstApp @lhs.tcSubstPatSpine $ C.mkTyThunk $ ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @knArgTy

SEM RecPatExpr
  | Ext         patExpr     .   ctyTopDown  =   cSubstApp @lhs.tcSubstPatSpine $ C.mkTyThunk $ ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @patTy

SEM CaseAlt
  | Pat         patExpr     .   ctyTopDown  =   @lhs.ctyPatTopDown
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: up passing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR Expr [ | | ctyBotUp: {C.Ty} ]

SEM Expr
  | *
                loc         .   ctyBotUp    =   @ctyTyAppRes
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: splitting into args/res for App
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instantiation info [InstTo] drives the splitting up into type and value args.
For now this is extracted from value bindings only, but must be done for other constructs as well.

%%[(8 codegen coresysf tycore)
SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (ctyTyAppArgL,ctyAppArg,ctyTyAppRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_ArgBefore @finAppInstToLHere @func.ctyBotUp
  | * - App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (ctyTyAppArgL,_,ctyTyAppRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_InstOnly @finAppInstToLHere @cty
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | *           loc         .   tcTyArgAppWrap
                                            =   \e -> foldr (flip C.Expr_App) e $ @tcSubstAppSpine `cSubstApp` map C.tyL0BindToL1Val @ctyTyAppArgL
                            .   tcTyArgLamWrap
                                            =   \e -> foldr C.Expr_Lam e $ map (C.cSubstAppExprAndBinds @lhs.tcSubstLamSpine . C.tyL0BindToL1Bind) @ctyTyLamArgL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: splitting into args/res for Lam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instantiation info [InstTo] drives the splitting up into type and value args,
see remarks for finAppInstToL.

%%[(8 codegen coresysf tycore)
SEM Expr
  | Lam         
%%[[12
    LamImpl
%%]]
                loc         .   (ctyTyLamArgL,ctyLamArg,ctyLamRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_ArgAfter @finLamInstToLHere @lhs.ctyTopDown
                            .   ctyLamArgHere
                                            =   @tcSubstLamSpine `cSubstApp` C.unTySeq @ctyLamArg
  | * - Lam
%%[[12
    LamImpl
%%]]
                loc         .   (ctyTyLamArgL,_,ctyTyLamRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_InstOnly @finLamInstToLHere @lhs.ctyTopDown
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: matching, in relation to type inference'd types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the instantiation of a lambda
ATTR Expr [ | | tcSubstAppSpine: {C.CSubst} ]
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Var Con     loc         .   ctyForMatch =   ctyBareFromTy @lhs.finTyVarMp @ty_g_
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Var Con     loc         .   moutFun     =   C.tyMatchBind @ctyForMatch $ ctyBareFromTy @lhs.finTyVarMp @ty
                            .   tcSubstAppSpine
                                            =   C.moutCSubst @moutFun
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcSubstAppSpine
                                            =   @func.tcSubstAppSpine
  | * - Var Con App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcSubstAppSpine
                                            =   (emptyCSubst :: C.CSubst)
%%]

%%[(8 codegen coresysf tycore)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the abstraction of a lambda
ATTR Expr [ tcSubstLamSpine: {C.CSubst} | | ]
%%]

%%[(8 codegen coresysf tycore)
SEM Decl
  | Val         loc         .   ctyExprKnTy =   ctyBareFromTy @lhs.finTyVarMp @exprKnTy
                            .   ctyExprTy   =   ctyBareFromTy @lhs.finTyVarMp @expr.ty
                            .   moutExpr    =   C.tyMatchBind @ctyExprKnTy @ctyExprTy
                            .   tcSubstLamSpine
                                            =   C.moutCSubst @moutExpr
  | FFI         loc         .   ctyExprTy   =   C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) @finalTyExpanded
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstLamSpine
                                            =   @lhs.tcSubstLamSpine
  | * - Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstLamSpine
                                            =   (emptyCSubst :: C.CSubst)
%%]

%%[(8 codegen coresysf tycore)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the @lhs.ctyTopDown over constituents
ATTR AllPatExpr [ tcSubstPatSpine: {C.CSubst} | | ]
%%]

%%[(8 codegen coresysf tycore)
SEM CaseAlt
  | Pat         loc         .   tcSubstPatSpine
                                            =   emptyCSubst
SEM Decl
  | Val         loc         .   tcSubstPatSpine
                                            =   emptyCSubst
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstPatSpine
                                            =   emptyCSubst
%%]

%%[(8 codegen coresysf tycore)
SEM PatExpr
  | AppTop Rec  loc         .   moutPat     =   C.tyMatchBind @ctyPat $ C.tyUnThunkTySeq @lhs.ctyTopDown
                            .   tcSubstPatSpine
                                            =   C.moutCSubst @moutPat
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM AGItf
  | AGItf       expr        .   tcSubstLamSpine
                                            =   emptyCSubst

SEM CaseAlt
  | Pat         expr        .   tcSubstLamSpine
                                            =   emptyCSubst

SEM DataFieldExpr RecExpr
  | Expr Upd    expr        .   tcSubstLamSpine
                                            =   emptyCSubst

SEM RecExpr
  | Ext         expr        .   tcSubstLamSpine
                                            =   emptyCSubst

%%[[9
SEM Decl
  | InstanceIntro
%%[[90
    FFE
%%]]
                expr        .   ctyTopDown  =   C.tyErr "Decl.InstanceIntro.ctyTopDown"
                            .   tcSubstLamSpine
                                            =   emptyCSubst
%%]]

%%[[97
SEM PatExpr
  | Expr        expr        .   ctyTopDown  =   C.tyErr "PatExpr.Expr.ctyTopDown"
                            .   tcSubstLamSpine
                                            =   emptyCSubst
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Strictness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AllDecl [ isStrict: Bool | | ]

SEM Expr
  | Let         loc         .   howToValBind=   if @isStrict then C.ValBindCateg_Strict else C.ValBindCateg_Rec
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore hmtyinfer)
ATTR NTCode [ | tcSubst: {C.CSubst} | ]

SEM AGItf
  | AGItf       loc         .   tcSubst             =   emptyCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AGItf [ | | tcmodule: {C.Module} ]
%%]

For now:

%%[(8 codegen coresysf tycore)
SEM AGItf
  | AGItf       lhs         .   tcmodule    =   let -- b = if @insertMainUse then Expr_Var hsnMain else @expr.letTCBody
                                                    -- d = if @insertMainDef then acoreLet C.ValBindCateg_Plain [C.mkValBind1 hsnMain @expr.letTCBody] else id
                                                    tyBindL = concatMap snd $ @expr.letTyBindL
                                                in  C.Module_Mod @lhs.moduleNm
                                                      [] -- [ (tn,Map.toList m) | (tn,dgi) <- gamToAssocL @expr.gathDataGam, not (dgiIsNewtype dgi), let m = Map.map dtiCTag $ dgiConstrTagMp dgi ]
                                                      ( tyBindL ++
                                                        map
                                                          (C.cSubstAppValBind True @expr.tcSubst)
                                                          (concatMap snd $
                                                             ((@extraValBindL ++ @expr.frontValBindL ++ @expr.letValBindL)
%%[[90
                                                             ++ @expr.backValBindL
%%]]
                                                      )   )  )
                loc         .   extraValBindL
                                            =   []
%%]

%%[(9 codegen coresysf tycore)
SEM AGItf
  | AGItf       loc         .   extraValBindL
                                            :=  [(C.ValBindCateg_Rec,@chrScopeMainBindLTC)]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% C.Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR Expr [ | | tcexpr: {C.Expr} ]
%%]

%%[(8 codegen coresysf tycore noHmTyRuler)
SEM Expr
  | IConst      loc         .   tcexprBase  =   C.mkExprSeq $ C.Expr_Int (toInteger @int) @cty
  | CConst      loc         .   tcexprBase  =   C.mkExprSeq $ C.Expr_Char @char @cty
  | Var         loc         .   tcexprBase  =   C.mkExprUnThunk $ acoreVar @nm
  | Con         loc         .   tcexprBase  =   C.mkExprUnThunk $ acoreVar @nm
  | SConst      loc         .   tcexprBase  =   acoreBuiltinString @lhs.opts @str
%%[[97
  | IIConst     loc         .   tcexprBase  =   acoreBuiltinInteger @lhs.opts @integer
%%]]
%%]

%%[(8 codegen coresysf tycore noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
                loc         .   (tcexpr,tcexprCSubst)
                                            =   foAppLRTCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @lhs.tcSubst $ @tcTyArgLamWrap $ @tcTyArgAppWrap @tcexprBase
                lhs         .   tcSubst     =   cSubstApp @lhs.tcSubst @tcexprCSubst
  | Let         loc         .   frontValBindL
                                            =   [(C.ValBindCateg_FFI,@decls.ffiValBindL)]
%%[[90
                            .   backValBindL=   [(C.ValBindCateg_FFE,@decls.ffeValBindL)]
%%]]
                            .   letTyBindL  =   [(@howToValBind,@dataTyBindL  ++ @decls.tyBindL )]
                            .   letValBindL =   [(@howToValBind,@dataValBindL ++ @decls.valBindL)]
                            .   letValBindOtherL
                                            =   []
                            .   tcexprtop   =   foldr (\(c,b) e -> acoreLet c b e) @letTCBody @letTCValBindRemL
                            .   tcSubstTop  =   @body.tcSubst
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcexprArg   =   @arg.tcexpr
                            .   tcexprThArg =   C.mkExprThunk @tcexprArg
                            .   (tcexprapp,tcexprappCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @arg.tcSubst @appImplsCoeLTC []
                                                    (f ,s2)   = C.coeEvalOnAsSubst u2 ww @func.tcexpr
                                                in  (@tcTyArgLamWrap $ @tcTyArgAppWrap $ acore1App f @tcexprThArg, s1 `cSubstApp` s2)
                            .   tcexpr      =   if @func.isNewtype then @tcexprArg else @tcexprapp
                lhs         .   tcSubst     =   cSubstApp @arg.tcSubst @tcexprappCSubst
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcArgWrap   =   \e -> rceMatchTy @rceEnvTC [(@arg.topNm,@ctyLamArgHere)] [RAlt_Alt [@arg.rpatTC] e Set.empty] -- @body.caseFailS]
                            .   (tcexpr,tcexprlamCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @body.tcSubst @lamBodyCoeLTC @lamArgCoeLTC
                                                    (b ,s2)   = C.coeEvalOnAsSubst u2 ww @body.appFunExprTC
                                                in  (@tcTyArgLamWrap b, s1 `cSubstApp` s2)
                lhs         .   tcSubst     =   cSubstApp @body.tcSubst @tcexprlamCSubst
  | AppTop      loc         .   tcexprtop   =   @expr.tcexpr
                            .   tcSubstTop  =   @expr.tcSubst
  | Rec         loc         .   tcexprtop   =   @rtcexpr
                            .   tcSubstTop  =   @recExpr.tcSubst
  | AppTop Rec Let
                loc         .   (tcexpr,tcexprapptopCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @tcSubstTop [] @lamArgCoeLTC
                                                    (e ,s2)   = C.coeEvalOnAsSubst u2 ww @tcexprtop
                                                in  (e, s1 `cSubstApp` s2)
  | AppTop      lhs         .   tcSubst     =   cSubstApp @expr.tcSubst @tcexprapptopCSubst
  | Rec         lhs         .   tcSubst     =   cSubstApp @recExpr.tcSubst @tcexprapptopCSubst
  | Let         lhs         .   tcSubst     =   cSubstApp @body.tcSubst @tcexprapptopCSubst
  | Ann         loc         .   tcexpr      =   @tcTyArgLamWrap $ @tcTyArgAppWrap @expr.tcexpr
  | TypeAs      loc         .   (tcexpr,tcexprtypeasCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (e1,s1)   = foAppLRTCoeAsSubst @lhs.opts u1 @fo_fitDown @lhs.finTyVarMp @expr.tcSubst @expr.tcexpr
                                                    (e2,s2)   = foAppLRTCoeAsSubst @lhs.opts u2 @fo_        @lhs.finTyVarMp @expr.tcSubst e1
                                                in  (e2, s1 `cSubstApp` s2)
                lhs         .   tcSubst     =   cSubstApp @expr.tcSubst @tcexprtypeasCSubst
  | Case        loc         .   tcexpr      =   let (ns,bs,as)
                                                      = if @isTupOfArg
                                                        then let ns = [ (n, ty "1" n) | (C.Expr_Var n) <- C.fuL2ExprL (reverse @expr.tcfuExprL) ]
                                                             in  (ns,[],@alts.raltTCL')
                                                        else let n = uidHNm @lUniq2
                                                             in  ([(n, ty "2" n)],[C.mkValBind1 n (ty "3" n) @expr.tcexpr],@alts.raltTCL)
                                                    ty m n = C.tyErr ("Expr.Case.tcexpr." ++ m ++ ": " ++ show n)
                                                in  acoreLet C.ValBindCateg_Plain bs (rceMatchTy @rceEnvTC ns as)
  | CaseAltFail loc         .   tcexpr      =   C.Expr_CaseAltFail (CaseAltFailReason_Continue @caseId) (acoreBuiltinError @lhs.opts ("FAIL " ++ show @caseId))
  | Undefined   loc         .   tcexpr      =   acoreBuiltinUndefined @lhs.opts
  | Parens      loc         .   tcexpr      =   @expr.tcexpr
%%]

%%[(9 codegen coresysf tycore)
SEM Expr
  | Let         loc         .   letValBindOtherL
                                            :=  [ (C.ValBindCateg_Rec,@chrScopeBindLTC) ]
%%]

%%[(10 codegen coresysf tycore)
SEM Expr
  | DynVar      loc         .   tcexpr      =   acoreBuiltinUndefined @lhs.opts
%%]

%%[(97 codegen coresysf tycore)
SEM PatExpr
  | Expr        loc         .   tcexprBaseEq=   acoreVar @eqFldNm
                            .   (tcexpr,tcexprpatCSubst)
                                            =   let (e,s) = foAppLRTCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @expr.tcSubst @tcexprBaseEq
                                                in  (acoreApp e [@expr.tcexpr], s)
                lhs         .   tcSubst     =   cSubstApp @expr.tcSubst @tcexprpatCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr: lam arg code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR Expr [ | | tcLamArgs: {[(HsName,C.Expr->C.Expr)]} ]
ATTR Expr [ | | tcLamBody: {C.Expr} ]

SEM Expr
  | Lam         lhs         .   tcLamArgs   =   (@arg.topNm,@tcArgWrap) : @body.tcLamArgs
                            .   tcLamBody   =   @body.tcLamBody
  | * - Lam     lhs         .   tcLamArgs   =   []
                            .   tcLamBody   =   @tcexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr: CExpr stuff: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   tcexpr      =   Expr_Int  @int
  | CConst      loc         .   tcexpr      =   Expr_Char @char
  | Var         loc         .   tcexpr      =   Expr_Var  @nm
  | Con         loc         .   tcexpr      =   Expr_Var  @nm
%%[(8888 codegen coresysf tycore)

SEM Expr
%%]

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   tcexprBase  :=  Expr_Int @int
  | CConst      loc         .   tcexprBase  :=  Expr_Char @char
  | Var         loc         .   tcexprBase  :=  Expr_Var @nm
  | Var IConst CConst
                loc         .   tcexpr      :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @tcexprBase
  | Con         loc         .   tcexprBase  :=  Expr_Var @nm
                            .   tcexpr      :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @tcexprBase

-- between variant 5 .. 99, reconstruction of AG rules, getting rid of ruler3 until Arie's ruler4 can be used
%%[(8888 codegen coresysf tycore noHmTyRuler)
SEM Expr
%%]

%%[(8888 codegen coresysf tycore noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]]
%%]

%%[(9999 codegen coresysf tycore)
SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | AppTop      loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | TypeAs      loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%[(99997 codegen coresysf tycore)
SEM PatExpr
  | Expr        loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM Expr
  | Rec         loc         .   rtcexpr         =   
%%[[10  
                                                    if  not (@recExpr.isExtFromEmpty)
                                                    then  C.fuMkExpr @lhs.opts @lUniq3 (reverse @recExpr.tcfuExprL) @recExpr.tcrecExpr
                                                    else
%%]]                                                    
                                                          C.Expr_Node {- CTagRec -} $ C.fuL2ExprNodeFldL True Just $ rowCanonOrder @recExpr.tcfuExprL
%%]
                                                          foldl acore1App (C.Expr_Tup CTagRec)
                                                            $ C.fuL2ExprL $ rowCanonOrder $ @recExpr.tcfuExprL

%%[(8888 codegen coresysf tycore)
SEM Expr
  | Rec         
%%[[10
                loc         .   lUniq3          :   UNIQUEREF gUniq
%%]]
%%]

%%[(8 codegen coresysf tycore)
ATTR RecExpr [ | | tcrecExpr: {C.Expr} ]
ATTR RecExpr Expr [ | | tcfuExprL: {C.FieldUpdateL C.Expr} ]

SEM RecExpr
  | Empty       loc         .   tcrecExpr       =   acoreTup []
                lhs         .   tcfuExprL       =   []
  | Expr        loc         .   tcrecExpr       =   @expr.tcexpr
                lhs         .   tcfuExprL       =   []
  | Ext         loc         .   rtcexpr         =   C.Expr_TupIns @recExpr.tcrecExpr CTagRec @nm @tcoffset @expr.tcexpr
  | Upd         loc         .   rtcexpr         =   C.Expr_TupUpd @recExpr.tcrecExpr CTagRec @nm @tcoffset @expr.tcexpr
  | Ext Upd     lhs         .   tcfuExprL       =   if @knRecHasLab
                                                    then (@nm,(@rtcexpr,Nothing)) : @recExpr.tcfuExprL
                                                    else @recExpr.tcfuExprL

SEM Expr
  | * - Rec     lhs         .   tcfuExprL       =   []
%%]

%%[(8888 codegen coresysf tycore)
ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty
%%]

%%[(8 codegen coresysf tycore)
SEM RecExpr
  | Ext Upd     loc         .   tcoffset        =   acoreInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recExpr.ty)
%%]

%%[(1010 codegen coresysf tycore)
SEM RecExpr
  | Ext Upd     loc         .   offset          :=  cSubstApp @expr.tcSubst $ acoreNmHolePred @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM Expr
  | DataFields  loc         .   tcdfexpr    =   let mkTup dti mkDflt con
                                                      = C.Expr_Node {- (dtiCTag dti) -}
                                                        . C.fuL2ExprNodeFldL True (const Nothing)
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr" ("arity" >#< length dflt) v)
                                                        . listSaturateWith 0 (ctagArity (dtiCTag dti) - 1) (\(_,(_,Just o)) -> o) dflt
                                                        . C.fuMap (\l mke -> let o = dtiOffsetOfFld l dti in (mke dti o,o))
                                                      where dflt = [ (o,(f,(C.Expr_TupIns (acoreBuiltinUndefined @lhs.opts) (dtiCTag dti) f (acoreInt o) (mkDflt f),Just o)))
                                                                   | (f,i) <- Map.toList $ dtiFldMp dti, let o = dfiOffset i
                                                                   ]
                                                    ty m x = C.tyErr ("Expr.DataFields." ++ m ++ ": " ++ show x)
                                                in  if dgiIsNewtype @dgi
                                                    then acoreLet C.ValBindCateg_Plain @dataFieldExpr.dfeValBindL
                                                         $ head $ C.fuL2ExprL $ C.fuMap (\_ f -> (f emptyDataTagInfo 0,0)) $ @dataFieldExpr.tcfuExprL
                                                    else case @dataFieldExpr.mbConNm of
                                                           Just conNm
                                                             -> acoreLet C.ValBindCateg_Plain @dataFieldExpr.dfeValBindL
                                                                  (mkTup (dgiDtiOfCon conNm @dgi) (const $ acoreBuiltinUndefined @lhs.opts) @dataFieldExpr.tcdfeExpr @dataFieldExpr.tcfuExprL)
                                                           _ -> acoreLet C.ValBindCateg_Plain (err ++  @dataFieldExpr.dfeValBindL)
                                                                  (acoreSatSelsCasesTy (C.rceUpdEnv (acoreVar en) @rceEnvTC) (Just (mkHNm @lUniq,ty "1" @lUniq)) @dataFieldExpr.tcdfeExpr alts)
                                                             where alts = [ ( dtiCTag dti
                                                                            , [ (f,{-f,-}dfiOffset i) | (f,i) <- Map.toList $ dtiFldMp dti ]
                                                                            , Nothing
                                                                            , mkTup dti acoreVar (acoreTagTupTy (dtiCTag dti) (C.tyErr "Expr.DataFields.mkExprTuple")) @dataFieldExpr.tcfuExprL
                                                                            )
                                                                          | dti <- @dtiInFldL
                                                                          ]
                                                                   err = [C.mkValBind1 en (ty "error" en) (acoreBuiltinError @lhs.opts ("has no field update '" ++ show @fldL ++ "'"))]
                                                                   en = mkHNm "_upd_error"
                            .   tcexpr      =   @tcdfexpr
%%]

%%[(8 codegen coresysf tycore)
ATTR
  DataFieldExpr
    [ | | tcdfeExpr: {C.Expr}
          dfeValBindL: {C.ValBindL}
          tcfuExprL: {C.FieldUpdateL (DataTagInfo -> Int -> C.Expr)}
    ]

SEM DataFieldExpr
  | Upd         lhs         .   tcfuExprL   =   let mke dti o = C.Expr_TupIns @dataFieldExpr.tcdfeExpr (dtiCTag dti) @nm (acoreInt o) (acoreVar @fldExprNm)
                                                in  (@nm,(mke,Nothing)) : @dataFieldExpr.tcfuExprL
                            .   dfeValBindL =   let ty n = C.tyErr ("DataFieldExpr.Upd.fld: " ++ show n)
                                                in  C.mkValBind1 @fldExprNm (ty @fldExprNm) @expr.tcexpr : @dataFieldExpr.dfeValBindL
  | Con         lhs         .   tcdfeExpr   =   C.Expr_Tup (dtiCTag @dti)
                            .   tcfuExprL   =   []
                            .   dfeValBindL =   []
  | Expr        loc         .   tcdfeExpr   =   @expr.tcexpr
                            .   tcfuExprL   =   []
                            .   dfeValBindL =   []
%%]

%%[(8888 codegen coresysf tycore)
SEM DataFieldExpr
  | Upd         loc         .   fldExprNm   =   mkHNm @lUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, dissection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM Expr
  | Sel         loc         .   tcoffset    =   acoreInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @lbl @expr.ty)
                            .   tcexpr      =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq_freshKnTy
                                                     ty n = C.tyErr ("Expr.Sel.fld: " ++ show n)
                                                -- in   C.mkExprSelCase @rceEnvTC (Just (n1,ty n1)) @expr.tcexpr CTagRec n2 {- @lbl -} @tcoffset Nothing
                                                in   acoreSelCaseTy @rceEnvTC (Just (n1,ty n1)) @expr.tcexpr CTagRec n2 {- @lbl -} @tcoffset Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data constr wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM DataConstr
  | Constr      lhs         .   valBindL    =   []
%%]
                loc         .   ctyDataCon  =   C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) @finDataConTy
                lhs         .   valBindL    =   let len = length @dataConGadtFldTyL
                                                    nms = map (\i -> hsnFromString ("x" ++ show i)) [1..len]
                                                in  [ C.mkValThunkBind1 @conNm @ctyDataCon
                                                         (let (mk,(args,res)) = C.tcMergeLamTySeqAndArgNms @ctyDataCon nms
                                                          in  mk (if @lhs.isNewtype
                                                                  then C.mkCast (C.tyUnThunkTySeq $ head args) res
                                                                       $ C.mkExprUnThunk $ acoreVar $ head nms
                                                                  else -- C.mkCast (C.mkTySeq $ C.Expr_Node @ctag [ C.ExprSeq1_L0Val a | a <- args ] ) res
                                                                       C.mkInject @ctag res
                                                                       $ C.Expr_Node {- @ctag -} $ C.fuL2ExprNodeFldL False (const Nothing) [ (n,(acoreVar n,Nothing)) | n <- nms ]
                                                                   -- acoreApp (C.Expr_Tup @ctag) (map acoreVar nms)
                                                         )       )
                                                    ]
                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data field selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
SEM Decl
  | Data        loc         .   fldSelValBindL
                                            =   let (xn1:xn2:_) = hsnLclSupply
                                                    tgSels f i = [ (t,[(f,o)],Nothing,acoreVar f) | (t,o) <- Map.toList $ dficInTagMp i ]
                                                    dataTy = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) @dataTy
                                                in  if @isNewtype
                                                    then [ [ C.mkValThunkBind1 f (acoreVar $ ehbnId $ ehcOptBuiltinNames @lhs.opts)
                                                           | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         ] ]
                                                    else [ [ C.mkValThunkBind1 f
                                                               (mkExprLam [xn1]
                                                                 (acoreSatSelsCasesTy (C.rceUpdEnv (acoreVar en) @rceEnvTC) (Just xn2) (acoreVar xn1) (tgSels f i)))
                                                           , C.mkValBind1 en (acoreBuiltinError @lhs.opts ("has no field selection '" ++ show f ++ "'"))
                                                           ]
                                                         | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         , let en = hsnUniqifyStr HsNameUniqifier_New "datafield_sel_error" f -- hsnSuffix f "_datafield_sel_error"
                                                         ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: all bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
SEM Decl
  | Data        lhs         .   valBindL    =   concat @fldSelValBindL ++ @constrs.valBindL
%%]

%%[(8 codegen coresysf tycore) hs
-- | Make bindings for constructors, given various bits of info
mkDataValBindL :: EHCOpts -> CTag -> HsName -> Bool -> C.Ty -> C.ValBindL
mkDataValBindL opts ctag conNm isNewtype ty
  = [ C.mkValThunkBind1 conNm ty
         (let (mk,(args,res)) = C.tcMergeLamTySeqAndArgNms ty nms
          in  mk (if isNewtype
                  then C.mkCast (C.tyUnThunkTySeq $ head args) res
                       $ C.mkExprUnThunk $ acoreVar $ head nms
                  else -- C.mkCast (C.mkTySeq $ C.Expr_Node ctag [ C.ExprSeq1_L0Val a | a <- args ] ) res
                       C.mkInject ctag res
                       $ C.Expr_Node {- @ctag -} $ C.fuL2ExprNodeFldL False (const Nothing) [ (n,(acoreVar n,Nothing)) | n <- nms ]
                   -- acoreApp (C.Expr_Tup ctag) (map acoreVar nms)
         )       )
    ]
  where nms = (map (\i -> hsnFromString ("x" ++ show i)) [1 .. ctagArity ctag])
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Let         loc         .   dataValBindL=   mkDataBinds
                                                    (\isNewtype
                                                      (DataTagInfo
                                                        { dtiConNm    = conNm
                                                        , dtiConTy    = conTy
                                                        , dtiFldMp    = fldMp
                                                        , dtiCTag     = ctag
                                                        }) -> let ty = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) $ @lhs.finTyVarMp `varUpd` conTy
                                                              in  mkDataValBindL @lhs.opts ctag conNm isNewtype ty
                                                    )
                                                    @decls.gathDeclDataGam
                            .   dataTyBindL =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: type bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM Decl
  | Data        loc         .   ctyData     =   let t = if @isNewtype
                                                        then snd (snd (tyRecExts2 @dataAltTy !! 0) !! 0)
                                                        else @dataAltTy
                                                in  C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam)
                                                    $ ((assocTyLToVarMp $ zipWith (\t n -> (tyVar t, appCon n)) @tyVars.tyL @tyVars.nmL) `varUpd`)
                                                    $ t
                lhs         .   tyBindL     =   let nms = @tyVars.nmL
                                                    (mk,_) = C.tcMergeLamTySeq1AndArgNms @cki nms
                                                in  [ C.mkTyBind1 @tyNm @cki (mk @ctyData)
                                                    ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR PatExpr [ | | rpatTC: {C.RPat} ]

SEM PatExpr
  | IConst      loc         .   rpatTC      =   RPat_Int @tcpNm C.tyInt (toInteger @int)
  | CConst      loc         .   rpatTC      =   RPat_Char @tcpNm C.tyChar @char
  | SConst      loc         .   rpatTC      =   RPat_Int @tcpNm C.tyInt (-1) -- for now
  | Var         loc         .   rpatTC      =   RPat_Var @tcpNm @cty False
  | VarAs       loc         .   rpatTC      =   @patExpr.rpatTC {rcpPNm = @tcpNm}
  | Con         loc         .   rpatTC      =   RPat_Con @tcpNm (C.tyErr "PatExpr.Con.rpatTC") @tag (RPatConBind_One C.PatRest_Empty [])
  | AppTop      loc         .   rpatTC      =   RPat_Con @tcpNm @cty {- (C.tyErr "PatExpr.AppTop.rpatTC") -} @tag (RPatConBind_One @tcrest (map fst @rpatValBinds))
  | Rec         loc         .   rpatTC      =   case @tcrest of
                                                    C.PatRest_Empty
                                                      ->  RPat_Con @tcpNm (C.tyErr "PatExpr.Rec.Empty.rpatTC") @tag (RPatConBind_One @tcrest (map fst @rpatValBinds))
                                                    C.PatRest_Var r
                                                      ->  RPat_Con @tcpNm (C.tyErr "PatExpr.Rec.Var.rpatTC") @tag (RPatConBind_One @tcrest pbL)
                                                          where  pbL = map fst $ C.fsL2PatOffsetL $ C.fsLReorder @lhs.opts $ reverse $ @tcfsRPatL
  | DataFields  loc         .   rpatTC      =   RPat_Con @tcpNm (C.tyErr "PatExpr.DataFields.rpatTC") @tag
                                                    (rpatConBindUnFlatten (RPatConBind_One @tcrest $ map fst @rpatValBind0)
                                                     $ map (RPatConBind_One @tcrest . map fst)
                                                           @rpatValBindss
                                                    )
  | Irrefutable loc         .   rpatTC      =   RPat_Irrefutable @tcpNm (C.tyErr "PatExpr.Irrefutable.rpatTC") @patExpr.valBindL
  | Bang 		loc         .   rpatTC      =   @patExpr.rpatTC	-- TBD
%%]

%%[(97 codegen coresysf tycore)
SEM PatExpr
  | Expr        loc         .   rpatTC      =   RPat_BoolExpr @tcpNm (C.tyErr "PatExpr.Expr.rpatTC") @tcexpr @mbConst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rest of Pat (for extensible records)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AllPatExpr [ | | patTCRest: {C.PatRest} ]

SEM RecPatExpr
  | Empty       lhs         .   patTCRest   =   C.PatRest_Empty
  | Ext         lhs         .   patTCRest   =   @recPatExpr.patTCRest

SEM DataFieldPatExpr
  | Con         lhs         .   patTCRest   =   C.PatRest_Empty
  | Ext         lhs         .   patTCRest   =   @dataFieldPatExpr.patTCRest

SEM PatExpr
  | Var         lhs         .   patTCRest   =   C.PatRest_Var @nm
  | * - Var     lhs         .   patTCRest   =   C.PatRest_Empty
%%]

%%[(8 codegen coresysf tycore)
SEM PatExpr
  | AppTop Con  loc         .   tcrest      =   C.PatRest_Empty
  | Rec         loc         .   tcrest      =   @recPatExpr.patTCRest
  | DataFields  loc         .   tcrest      =   @dataFieldPatExpr.patTCRest
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
SEM PatExpr
  | AppTop Con  loc         .   tag         =   let  (c,_)  = appUnApp @finKnPatTy -- tyAppFunArgsWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @knPatTy
                                                     dgi    = panicJust ("PatExpr.{AppTop,Con}.dgi: " ++ show (tyConNm c))
                                                              $ dataGamLookup (tyConNm c) $ @lhs.dataGam
                                                in   dtiCTag
                                                     $ panicJust ("PatExpr.{AppTop,Con}.tag: " ++ show (tyConNm c) ++ "." ++ show @appFunNm)
                                                     $ Map.lookup @appFunNm $ dgiConstrTagMp dgi
  | Rec         loc         .   tag         =   CTagRec
  | DataFields  loc         .   tag         =   dtiCTag @dataFieldPatExpr.dti
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Offset/label description of pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AllPatExpr [ | | tcfsRPatL: {C.FieldSplitL} ]

SEM DataFieldPatExpr
  | Con         lhs         .   tcfsRPatL   =   []
  | Ext         lhs         .   tcfsRPatL   =   (C.FldKnownOffset @nm @ioffset,@patExpr.rpatTC) : @dataFieldPatExpr.tcfsRPatL

SEM RecPatExpr
  | Empty       lhs         .   tcfsRPatL   =   []
  | Ext         lhs         .   tcfsRPatL   =   (C.FldComputeOffset @nm @tcoffset,@patExpr.rpatTC) : @recPatExpr.tcfsRPatL

SEM PatExpr
  | App         lhs         .   tcfsRPatL   =   (C.FldImplicitOffset,@arg.rpatTC) : @func.tcfsRPatL
  | AppTop      loc         .   tcfsRPatL   =   @patExpr.tcfsRPatL
  | Rec         loc         .   tcfsRPatL   =   @recPatExpr.tcfsRPatL
  | DataFields  loc         .   tcfsRPatL   =   @dataFieldPatExpr.tcfsRPatL
  | Con         loc         .   tcfsRPatL   =   []
  | * - App Con Rec
                lhs         .   tcfsRPatL   =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Offsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM DataFieldPatExpr
  | Ext         loc         .   tcoffset    =   acoreInt @ioffset :: C.Expr

SEM RecPatExpr
  | Ext         loc         .   tcoffset    =   acoreInt @ioffset :: C.Expr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat bindings based on offsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM PatExpr
  | AppTop      loc         .   rpatValBinds=   C.fsL2PatOffsetL $ reverse                 $ @tcfsRPatL
  | Rec         loc         .   rpatValBinds=   C.fsL2PatOffsetL $ rowCanonOrderBy compare $ @tcfsRPatL
  | DataFields  loc         .   (rpatValBindss,rpatValBindsNonSat,rpatValBind0)
                                            =   let fsL = reverse @tcfsRPatL
                                                    grp = groupByOn (\o1 o2 -> (C.foffOffset o1 `compare` C.foffOffset o2) /= GT) fst
                                                    max = ctagArity @tag - 1
                                                    sat = -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                          listSaturateWith 0 max (C.foffOffset . fst)
                                                            (zipWith (\o n -> (o,(C.FldKnownOffset n o,RPat_Var (RPatNmOrig n) (ty n) False))) [0..max] hsnLclSupply)
                                                    ty n = C.tyErr ("PatExpr.DataFields.fld: " ++ show n)
                                                in  ( map (C.fsL2PatOffsetL . sat) $ grp fsL      -- groups of bindings which can be dealt with simultaneously
                                                    , C.fsL2PatOffsetL fsL                        -- bindings
                                                    , C.fsL2PatOffsetL $ sat []                   -- 0 binding
                                                    )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in (recursive) let bindings (lazy unpacking)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR AllPatExpr [ | | valBindL USE {++} {[]}: {C.ValBindL} ]

SEM PatExpr
  | AppTop Rec  loc         .   valBindL      =   acoreRPatBindL2BindL @rceEnvTC (not $ null @valBindLSub) @lhs.ceParentNm @tag (Just (@tcrest,length @tcfsRPatL)) @rpatValBinds 
  | DataFields  loc         .   valBindL      =   acoreRPatBindL2BindL @rceEnvTC (not $ null @valBindLSub) @lhs.ceParentNm @tag (Just (@tcrest,ctagArity @tag)) @rpatValBindsNonSat 
  | AppTop Rec DataFields
                lhs         .   valBindL      =   @valBindL ++ @valBindLSub
%%]

%%[(8 codegen coresysf tycore)
SEM PatExpr
  | AppTop      loc         .   valBindLSub   =   @patExpr.valBindL
  | Rec         loc         .   valBindLSub   =   @recPatExpr.valBindL
  | DataFields  loc         .   valBindLSub   =   @dataFieldPatExpr.valBindL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR PatExpr [ | | tcpNm: {RPatNm} ]

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable Bang
%%[[97
    Expr
%%]]
                loc         .   tcpNm       =   maybe (RPatNmUniq @topNm) RPatNmOrig @mbTopNm
  | App         loc         .   tcpNm       =   @arg.tcpNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
SEM DataFieldPatExpr

SEM RecPatExpr
%%]
  | Ext         loc         .   offset      =   Expr_Int (tyRecOffset @nm (@lhs.finTyVarMp `varUpd` @recPatExpr.ty))

%%[(1010 codegen coresysf tycore)
SEM RecPatExpr
  | Ext         loc         .   offset      :=  cSubstApp @patExpr.tcSubst $ acoreNmHolePred @prUid
%%]

%%[(8888 codegen coresysf tycore)
ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | App         arg         .   ceParentNm  =   rpatNmNm @arg.tcpNm

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   rpatNmNm @patExpr.tcpNm

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm
%%]

%%[(1212 codegen coresysf tycore)
SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercions resulting from pred usage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
SEM Expr
  | App AppImpred
%%[[8
                loc         .   appImplsCoeLTC      =   []
%%][9
                loc         .   appImplsCoeLTC      =   (acoreCoePoiLApp $ map poPoi @prOccL) ++ [C.Coe_ImplApp $ ipoId @imPrvOcc]
%%]]
%%]

%%[(12 codegen coresysf tycore)
SEM Expr
  | AppImpl     loc         .   appImplsCoeLTC      =   []
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lamBodyCoeLTC       =   C.mkLamBodyCoe (acoreCoeMap (@tcArgWrap . @closeExistsWrap)) @body.appArgCoeLTC
%%]

%%[(8 codegen coresysf tycore)
SEM Expr
  | Lam         loc         .   lamArgCoeLTC        =
%%[[9
                                                        acoreCoePoiLLamTy
                                                            (acoreCoeLetRec @poiBindLTC)
                                                            (zip @poiL (repeat (C.tyErr "Expr.Lam.acoreCoePoiLLamTy")))
                                                        ++
%%]]
                                                        [acoreCoeLam1Ty @arg.topNm @ctyLamArgHere]
  | AppTop Rec Let
%%[[8
                loc         .   lamArgCoeLTC        =   []
%%][9
                loc         .   lamArgCoeLTC        =   acoreCoePoiLLamTy
                                                            (acoreCoeLetRec @poiBindLTC)
                                                            (zip @poiL (repeat (C.tyErr "Expr.AppTop.acoreCoePoiLLamTy")))
%%]]
%%]

%%[(12 codegen coresysf tycore)
SEM Expr
  | LamImpl     loc         .   lamArgCoeLTC        =   [acoreCoeLam1Ty @arg.topNm @ctyLamArgHere `acoreCoeCompose` acoreCoeLetRec @poiBindLTC]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering coercions/cexpr for app args for optimization by weaving above apptop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR Expr [ | | appArgCoeLTC: {[C.Coe]}  appFunExprTC: {C.Expr} ]

SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                lhs         .   (appArgCoeLTC,appFunExprTC)
                                                =   if @func.isNewtype
                                                    then ([],@tcexprArg)
                                                    else (@func.appArgCoeLTC ++ @appImplsCoeLTC ++ [acoreCoeApp1 @tcexprThArg],@func.appFunExprTC)
  | AppTop      lhs         .   (appArgCoeLTC,appFunExprTC)
                                                =   if null @lamArgCoeLTC
                                                    then (@expr.appArgCoeLTC,@expr.appFunExprTC)
                                                    else ([],@tcexpr)
  | * - App AppImpred AppTop
%%[[12
    AppImpl
%%]]
                lhs         .   appArgCoeLTC   =   []
                            .   appFunExprTC   =   @tcexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR
  AllDecl AllDataConstr
    [ | | valBindL
        , tyBindL
        , ffiValBindL
%%[[90
        , ffeValBindL
%%]]
          USE {++} {[]}: {C.ValBindL}
    ]
ATTR AllNT KiExprAnn TyExprAnn ExprAnn PatExprAnn
  [ | | copy : SELF ]

SEM KiExprAnn
  | Empty       lhs         .   copy            =   KiExprAnn_Empty

SEM TyExprAnn
  | *           lhs         .   copy            =   TyExprAnn_Empty

SEM ExprAnn
  | *           lhs         .   copy            =   ExprAnn_Empty

SEM PatExprAnn
  | *           lhs         .   copy            =   PatExprAnn_Empty
%%]

%%[(8 codegen coresysf tycore)
SEM Decl
  | Val         loc         .   tcVal           =   (if @lhs.isStrict then id else C.mkExprThunk) @expr.tcexpr -- $ C.tcMergeArgTypeSeqAndCode @ctyLam2ArgL @expr.tcLamArgs @expr.tcLamBody
                lhs         .   valBindL        =   [C.mkValBind1 @patExpr.topNm @ctyBind @tcVal] ++ @patExpr.valBindL
%%]

%%[(9 codegen coresysf tycore)
SEM Decl
  | Val         lhs         .   valBindL        :=  [ C.mkValBind1 @patExpr.topNm @ctyBind $ acoreLetMerge True C.ValBindCateg_Rec @chrScopeValBindLTC @tcVal
                                                    ] ++ @patExpr.valBindL   -- '
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
%%]

%%[(8 codegen coresysf tycore)
SEM Decl
  | TySig       lhs         .   valBindL        =   []
  | FFI         lhs         .   ffiValBindL     =   [C.mkValBind1FFI @nm @ctyExprTy @ffiExpr]
                loc         .   ffiExpr         =   C.Expr_FFI @callconv @safety @impEnt @ctyExprTy
%%]

%%[(99994 codegen coresysf tycore)
  | FFE         loc         .   nmCoerced       =   mkHNmPrefix "coerced_" @nm
                lhs         .   valBindL        =   [C.mkValBind1 @nmCoerced @expr.tcexpr]
                            .   ffeValBindL     =   [ValBind_FFE @nm @callconv @expEnt @nmCoerced @finalTyExpanded]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Front/back bindings are inserted before/after the other bindings, though only on top level.
Meant for global defs like FFI/FFE.
Merging is done to group all mutual recursive stuff together, in particular instances which are out of order declared.
Reordering and splitting up in smaller groups is then done later by a Core transformation.

%%[(8 codegen coresysf tycore) hs
mkLetTCBodyBindL :: Bool -> C.ValBindCateg -> [(C.ValBindCateg,C.ValBindL)] -> [(C.ValBindCateg,C.ValBindL)] -> [(C.ValBindCateg,C.ValBindL)] -> C.Expr -> ([(C.ValBindCateg,C.ValBindL)],C.Expr)
mkLetTCBodyBindL isStrict howToBind locBindL locOthBindL bodyBindL body
  = if isStrict
    then (locOthBindL,foldr (\(c,b) e -> acoreLet c b e) body (merge $ locBindL ++ bodyBindL))
    else (merge $ locOthBindL ++ locBindL ++ bodyBindL, body)
  where merge (cb1@(c1,b1) : tl)
          = case merge tl of
              (c2,b2) : tl' | c1 == c2 && c1 == C.ValBindCateg_Rec
                  -> (c1,b1++b2) : tl'
              tl' -> cb1 : tl'
        merge [] = []
%%]

%%[(8 codegen coresysf tycore)
ATTR
  Expr
    [ | | letValBindL
        , letTyBindL
        , frontValBindL
%%[[90
        , backValBindL
%%]]
            : {[(C.ValBindCateg,C.ValBindL)]}
          letTCBody: {C.Expr}
    ]
%%]

For now: 

%%[(8 codegen coresysf tycore)
SEM Expr
  | Let         (loc.letTCValBindRemL,loc.letTCBody)
                                                =   mkLetTCBodyBindL @isStrict @howToValBind @letValBindL @letValBindOtherL @body.letValBindL @body.letTCBody
                lhs         .   letTyBindL      =   @letTyBindL ++ @body.letTyBindL
                            .   letValBindL     =   @letTCValBindRemL
                            .   frontValBindL   =   @frontValBindL ++ @body.frontValBindL
%%[[90
                            .   backValBindL    =   @backValBindL ++ @body.backValBindL
%%]]
  | * - Let     lhs         .   letTCBody       =   @tcexpr
                            .   letTyBindL      =   []
                            .   letValBindL     =   []
                            .   frontValBindL   =   []
%%[[90
                            .   backValBindL    =   []
%%]]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9999 codegen coresysf tycore) hs
cdictOffset :: HsName -> Ty -> Int
cdictOffset n r = tyRecOffset n $ r
%%]

%%[(9999 codegen coresysf tycore)
SEM Decl
  | Class       lhs         .   valBindL      =   let  x = mkHNm "x"
                                                     vx = Expr_Var x
                                                     xStrict = hsnUniqifyEval x
                                                     vxStrict = Expr_Var xStrict
                                                     mkSel n = acoreSatSelsCaseMetaTy
                                                                 ((emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}) (Just xStrict) CMetaVal_Dict vx @dictTag
                                                                 [(n,cdictOffset n @clsTyRec)] Nothing (Expr_Var n)
                                                     mkApp = if ehcCfgInstFldHaveSelf @lhs.opts
                                                             then (\f -> acore1AppMeta f vx CMetaVal_Dict)
                                                             else id
                                                     dDflt
                                                       = [C.mkValBind1 nDflt (mkExprLam1Meta nD CMetaVal_Dict d)] 
                                                       where nDflt = clgiDfltDictNm @clgi2
                                                             d = acoreApp (Expr_Tup @dictTag) (replicate (length $ snd $ tyRecExts $ @clsTyRec) (acoreBuiltinUndefined @lhs.opts))
                                                             nD = hsnUniqify HsNameUniqifier_SelfDict nDflt
                                                in   (maybe dDflt (const []) @mbDefaultInstNm)
                                                     ++ [ C.mkValBind1 n $ mkExprLam1Meta x CMetaVal_Dict $ mkApp $ mkSel n
                                                        | (n,_) <- @clsFldL
                                                        ]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Three Haskell-constructs give rise to an instance-declaration in EH.
In EH, they can be dicerned by inspecting @instVariant:
* InstNormal:   a normal HS instance-declaration
* InstDefault:  the default definitions of a HS class-declaration
* InstDeriving: a deriving-annotation in a data-declaration
The attribute below generates Core code for these.

As an example we show the processing of a simplified form of a HS class "Eq" 
and "Boolean" as an instance of it:

  class Eq a where
    eq :: a -> a -> Bool
    ne :: a -> a -> Bool
    ne x y = not (eq x y)   -- a default definition
                            -- To show how missing definitions are treated, we do not give a default definition for eq here, as in the Prelude
  instance Eq Boolean where
    eq x y = cond x y (not y)  -- the implementation of equality on booleans
                               -- For the "ne" function, it falls back on the default implementation

In the transformation below, before the actual Core code is generated, we have two auxiliary functions:
  * mkNormalD:  generates the dictionary for an instance definition (either from code supplied by the HS programmer, or generated because of "deriving")
  * mkDefaultD: generates the dictionary for a default definition
Also there are some local values:
  * some fresh variable names to be used in the Core code
  * some auxiliary lists, which hold transformations of the original member definitions
Some of these local values are local to mkNormalD or mkDefaultD, others can be definied generically for both.

The elements of the lists correspond to class members. The correspondence can be encode in two ways:
  * as an association list (either 2-tuples, or ValBinds)
  * positional: a fixed number of elements in a fixed order
We explain their meaning by showing example values during processing of the Eq code mentioned above.
Part of the processing is generating fresh names for members.
In the example, "03" is a prefix specific for the default definitions of class Eq, and "05" for the instance definition Eq Boolean.

We use a few notational conventions in the example:
 * what is shown as a string is really an HsName, thus "eq" really is HNm "eq"
 * we use => to denote a ValBind, thus  a=>b  means  ValBind a m b 
 * we omit the meta-annotation m in ValBinds.

 
memberNames          =  [       "eq",       "ne" ]  positional
memberNewNames       =  [     "03eq",     "03ne" ]  positional
      or, respectively, [     "05eq",     "05ne" ]  positional
memberNewVars        =  [ Var "03eq", Var "03ne" ]  positional
      or, respectively, [ Var "05eq", Var "05ne" ]  positional

defaultBindings      =  [                                               "ne"   => \xy.not(eq x y) ]  association
defaultBindingPairs  =  [                                              ("ne"   ,  \xy.not(eq x y))]  association
defaultMbBodies      =  [ Nothing                                , Just           \xy.not(eq x y) ]  positional
defaultMbNewNames    =  [ Nothing                                , Just "03ne"                    ]  positional
defaultBodies        =  [                   cundef               ,                \xy.not(eq x y) ]  positional
defaultNewBindings   =  [         "03eq" => cundef               ,      "03ne" => \xy.not(eq x y) ]  association, and also positional

instanceBindings     =  [         "eq" =>   \xy.cond x y (not y)                                  ]  association
instanceBindingPairs =  [        ("eq" ,    \xy.cond x y (not y))                                 ]  association
instanceMbBodies     =  [ Just              \xy.cond x y (not y) , Nothing                        ]  positional
instanceMbNewNames   =  [ Just    "05eq"                         , Nothing                        ]  positional
instanceMbNames      =  [ Just    "eq"                           , Nothing                        ]  positional
instanceNameMapping  =  [        ("eq"  ,   Var "05eq")                                           ]  association
instanceNewBindings  =  [         "05eq" => \xy.cond x y (not y)                                  ]  association


The primary use of these lists is generating the ...NewBindings.
But for the meta-annotation, also the ...MbNewNames lists are needed.
The other lists are auxiliary.


%%[(9999 codegen coresysf tycore)


SEM Decl
  | Instance    lhs         .   valBindL      =   let  (generatedDictionary, generatedMeta)
                                                       = case @instVariant of
                                                            InstNormal   -> mkNormalD  @decls.valBindL
                                                            InstDefault  -> mkDefaultD @decls.valBindL
%%[[91                                                            
                                                            InstDeriving -> mkNormalD  [ @loc.mkf dcf | dcf <- dclFldL @derivDCL ]
%%]]


                                                     memberNames     = [ n 
                                                                       | (n,_) <- rowCanonOrder @recTyExts 
                                                                       ]
                                                     memberNewNames  = [ hsnUniqifyStr HsNameUniqifier_DictField (show n) @dictNm -- hsnSuffix @dictNm ('~':show n)
                                                                       | n <- memberNames
                                                                       ]
                                                     memberNewVars   = map Expr_Var memberNewNames

                                                     rsltNm   = @dictBuildNm
                                                     rsltVar  = Expr_Var rsltNm
                                                                                                                                                                                       
                                                     mkNormalD instanceBindings
                                                       = let dfltNm       = clgiDfltDictNm @clgi
                                                             rsltNmStrict = hsnUniqifyEval rsltNm
                                                             dfltNmStrict = hsnUniqifyEval dfltNm
                                                             dfltVar      = Expr_Var dfltNm
                                                             rsltVarStrict= Expr_Var rsltNmStrict
                                                             dfltVarStrict= Expr_Var dfltNmStrict

                                                             instanceBindingPairs= [ (nm,v)
                                                                                   |  ValBind_Bind nm _ v <- instanceBindings
                                                                                   ]
                                                             instanceMbBodies    = map (flip lookup instanceBindingPairs) memberNames
                                                             instanceMbNewNames  = let f _ Nothing  = Nothing
                                                                                       f n (Just e) = Just n
                                                                                   in zipWith f memberNewNames instanceMbBodies
                                                             instanceMbNames     = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNames instanceMbNewNames
                                                             instanceNameMapping = [ (nm, CMetaVal_Val, v)
                                                                                   | (Just nm,v) <- zip instanceMbNames memberNewVars
                                                                                   ]
                                                             instanceNewBindings = [ C.mkValBind1Meta nm CMetaVal_Val v
                                                                                   | (nm,Just v) <- zip memberNewNames instanceMbBodies
                                                                                   ]
                                                                                   
                                                             superNewVars        = map Expr_Var @chrSuperProveNmL
                                                             superNameMapping    = zip3 @supClsFldNmL
                                                                                        (repeat CMetaVal_Dict)
                                                                                        superNewVars

                                                             superNameMapping2   = zip @supClsFldNmL
                                                                                       @chrSuperProveNmL
                                                             superPairs          = map getBindLeftAndRightVar @chrScopeSuperBindL
                                                             
                                                             doubleLookup :: HsName -> Maybe HsName
                                                             doubleLookup nm   =  do { nm2 <- lookup nm superNameMapping2
                                                                                     ; nm3 <- lookup nm2 superPairs
                                                                                     ; return nm3
                                                                                     }
                                                             
                                                             superMbNewNames   =  map doubleLookup memberNames

                                                             instanceAndSuperMbNewNames = let f (Just x) _ = Just x
                                                                                              f _ (Just y) = Just y
                                                                                              f _ _        = Nothing
                                                                                          in zipWith f instanceMbNewNames superMbNewNames

                                                             instanceCHRBindings = -- cSubstApp @decls.tcSubst
                                                                                                (  @chrAssumeSuperBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL 
                                                                                                ++ @chrAssumeDeclsCtxtBindL 
                                                                                                ++ @chrScopeSuperBindL 
                                                                                                ++ @chrScopeDeclsBindL
                                                                                                )

                                                             dict1     = acore1AppMeta dfltVar rsltVar CMetaVal_Dict
                                                             dict2     = Expr_Let C.ValBindCateg_Strict [bind1] (@loc.mkSetFlds superNameMapping    dfltVarStrict)
                                                             dict3     = Expr_Let C.ValBindCateg_Strict [bind2] (@loc.mkSetFlds instanceNameMapping rsltVarStrict)
                                                             dict4     = mkExprLetRec ([bind3] ++ instanceNewBindings ++ instanceCHRBindings) rsltVar
                                                             
                                                             bind1     = C.mkValBind1Meta dfltNmStrict CMetaVal_Dict dict1
                                                             bind2     = C.mkValBind1Meta rsltNmStrict CMetaVal_Dict dict2
                                                             bind3     = C.mkValBind1Meta rsltNm       CMetaVal_Dict dict3
                                                             contextArguments = acoreMetaLiftDict @chrCtxtArgNmL
                                                         in  ( acoreLamMetaTy contextArguments dict4   
                                                             , CMetaVal_DictInstance (Just (ctagTyNm @dictTag) : Just dfltNm : instanceAndSuperMbNewNames)
                                                             )

                                                     mkDefaultD defaultBindings
                                                       = let selfNm    = @dictSelfNm
                                                       
                                                             lookupMeta n = if n `elem` @supClsFldNmL then CMetaVal_Dict else CMetaVal_Val
                                                       
                                                             defaultBindingPairs = [ (nm,v)
                                                                                   |  ValBind_Bind nm _ v <- defaultBindings
                                                                                   ]
                                                             defaultMbBodies     = map (flip lookup defaultBindingPairs) memberNames
                                                             defaultMetas        = map lookupMeta                        memberNames
                                                             defaultBodies       = map (maybe (acoreBuiltinUndefined @lhs.opts) id) defaultMbBodies
                                                             defaultMbNewNames   = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNewNames defaultMbBodies
                                                             
                                                             defaultNewBindings  = zipWith3 C.mkValBind1Meta memberNewNames 
                                                                                                         defaultMetas
                                                                                                         defaultBodies
                                                             defaultCHRBindings  = -- cSubstApp @decls.tcSubst
                                                                                                (  @chrScopeDeclsBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL
                                                                                                )
                                                             dict5     = acoreApp (Expr_Tup @dictTag) memberNewVars
                                                             dict6     = mkExprLetRec ([bind5] ++ defaultNewBindings ++ defaultCHRBindings) rsltVar
                                                             
                                                             bind5     = C.mkValBind1Meta rsltNm CMetaVal_Dict dict5
                                                             
                                                         in  ( mkExprLam1Meta selfNm CMetaVal_Dict dict6
                                                             , CMetaVal_DictClass defaultMbNewNames
                                                             )

                                                in   [C.mkValBind1Meta @dictNm generatedMeta (generatedDictionary)]
  | InstanceIntro
                lhs         .   valBindL      =   [C.mkValBind1Meta @dictNm CMetaVal_Dict @expr.tcexpr]
%%]

%%[(9999 codegen coresysf tycore) hs

getBindRightVar :: ValBind -> Maybe HsName

getBindRightVar (ValBind_Bind _ _ (Expr_Var nm)) = Just nm
getBindRightVar _ = Nothing


getBindLeftAndRightVar :: ValBind -> (HsName,HsName)

getBindLeftAndRightVar (ValBind_Bind nm1 _ (Expr_Var nm2)) = (nm1,nm2)
getBindLeftAndRightVar _ = error "getBindLeftAndRightVar: not a bind"



%%]



An auxiliary local attribute that decides (based on an option) how
to set fields in a dictionary:
- by updates of a record
- by matching and rebuilding a datatype 

%%[(9999 codegen coresysf tycore)
SEM Decl
  | Instance    loc         .   mkSetFlds   =   let  off n = cdictOffset n @recTy
                                                     mkSetFldsRec ts d0
                                                       = foldl (\d (n,_,v) -> mkSet d n v) d0 ts
                                                       where mkSet d n v = Expr_TupUpd d @dictTag n (Expr_Int $ off n) v

                                                     mkSetFldsData ts d0
                                                       = acoreSatSelsCaseMetaTy env Nothing CMetaVal_Dict d0 @dictTag nmLblOffL Nothing sel
                                                       where env = (emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}
                                                             fullListWithTrivialValues = [ (o, (o, (Expr_Var n,CMetaVal_Val) ) ) 
                                                                                         | (n,o) <- nmLblOffL 
                                                                                         ]
                                                             sparseListWithInterestingValues = [ (off n, (v,m) ) 
                                                                                               | (n,m,v) <- ts
                                                                                               ]
                                                             arity = length @recTyExts
                                                             ns = take arity hsnLclSupply
                                                             nmLblOffL = zip ns [0..]
                                                             sel = acoreAppMeta   (Expr_Tup @dictTag) 
                                                                                  (map snd $ listSaturateWith 0 
                                                                                                              (arity-1) 
                                                                                                              fst 
                                                                                                              fullListWithTrivialValues
                                                                                                              sparseListWithInterestingValues
                                                                                  )
                                                   in  if   ehcCfgClassViaRec @lhs.opts  
                                                       then mkSetFldsRec  
                                                       else mkSetFldsData

%%]


An auxiliary local attribute that generates thee bindings for a DERIVED instance

%%[(99995 codegen coresysf tycore)
SEM Decl
  | Instance    loc         .   mkf         =   let   rsltNm   = @dictBuildNm
                                                      rsltVar  = Expr_Var rsltNm
                                                      
                                                      mkf :: DerivClsFld -> ValBind
                                                      mkf dcf
                                                       = C.mkValBind1 (dcfNm dcf)
                                                           (if fArity == 0
                                                            then mkExprLam (dcfInitialArgL dcf)
                                                                 $ dcfNoArgSubsExpr dcf @rceEnvTC
                                                                     [ (dti,mkcSubs dti (repeat []) altPrOccL) | (dti,altPrOccL) <- zip dtis @derivAltsPrOcc ]
                                                                     nrOfAlts rsltVar extraCxL (dcfInitialArgL dcf)
                                                            else mkExprLam (dcfInitialArgL dcf ++ take fArity nsA)
                                                                   (dcfWrapCase dcf @lhs.opts @derivDataDGI nrOfAlts n1 (dcfInitialArgL dcf)
                                                                    $ mkExprStrictSatCase @rceEnvTC (Just $ hsnUniqifyEval n1) n1v
                                                                      [ CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just $ n1subs ctag))
                                                                                 (mkc splDTI altInx (fArity - 1) n1s [n1subs ctag] altPrOccL)
                                                                      | (ctag,altPrOccL) <- zip (map dtiCTag dtis) @derivAltsPrOcc
                                                                      , let splDTI@(dtisLT,_,_) = splitDTIs ctag dtis
                                                                            altInx = length dtisLT
                                                                      ]
                                                           )       )
                                                       where n1v = Expr_Var n1
                                                             nsA@(n1:n1s) = hsnLclSupplyWith (mkHNm "x")
                                                             dtis  = panicJust "Decl.Instance.Deriving.dataGamDTIsOfTy" $ dataGamDTIsOfTy @derivHdDataTy @lhs.dataGam
                                                             nrOfAlts = length dtis
                                                             splitDTIs t ts -- in (lt,eq,gt), according to list ordering
                                                               = (l,e,g)
                                                               where (l,(e:g)) = span ((/= t) . dtiCTag) ts
                                                             fArity = (length $ appUnArrArgs $ dcfTy dcf) - dcfNrOmitTailArg dcf - length (dcfInitialArgL dcf) - 1 {- dictionary -}
                                                             n1subs t = nsubs t n1
                                                             nsubs t n = take (ctagArity t) $ hsnLclSupplyWith n
                                                             extraCxL = [ acoreNmHolePred (poPoi prOcc) | prOcc <- @derivExtraPrOcc ]
                                                             mkcSubs dti nmFldLL altPrOccL
                                                               = [ acoreAppMeta
                                                                     (Expr_Var (dcfNm dcf))
                                                                     (acoreMetaLiftDict [acoreNmHolePred (poPoi prOcc)]
                                                                       ++ acoreMetaLift (dcfInitialSubArgL dcf dti ++ map Expr_Var nmFldL))
                                                                 | (nmFldL,prOcc) <- zip nmFldLL altPrOccL
                                                                 ]
                                                             mkc tg@(dtisLT,dti,dtisGT) altInx arity nms nmFldLL altPrOccL
                                                               = case nms of
                                                                   (n:ns) | arity > 0
                                                                     -> mkExprStrictSatCase @rceEnvTC (Just $ hsnUniqifyEval n) (Expr_Var n)
                                                                          (   [ mka (dtiCTag dti) tsubs (mkc tg altInx (arity - 1) ns (nmFldLL ++ [tsubs]) altPrOccL) ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagLtExpr dcf) | t <- map dtiCTag dtisLT ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagGtExpr dcf) | t <- map dtiCTag dtisGT ]
                                                                          )
                                                                     where tsubs = nsubs (dtiCTag dti) n
                                                                           mka ctag nsubs e = CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just nsubs)) e
                                                                   _ -> dcfFoldSubsExpr dcf @lUniq @rceEnvTC dti (altInx, nrOfAlts) (dcfInitialArgL dcf)
                                                                        $ mkcSubs dti (transpose nmFldLL) altPrOccL
                                                in  mkf
%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen coresysf tycore)
ATTR CaseAlt [ | | raltTC: {C.RAlt}  raltTC': {C.RAlt} ]
ATTR CaseAlts [ | | raltTCL: {[C.RAlt]}  raltTCL': {[C.RAlt]} ]

SEM CaseAlt
  | Pat         lhs         .   raltTC      =   RAlt_Alt [@patExpr.rpatTC] @expr.tcexpr @expr.caseFailS
                            .   raltTC'     =   RAlt_Alt (C.fsL2PatL $ reverse @patExpr.tcfsRPatL) @expr.tcexpr @expr.caseFailS

SEM CaseAlts
  | Nil         lhs         .   raltTCL     =   []
                            .   raltTCL'    =   []
  | Cons        lhs         .   raltTCL     =   @hd.raltTC  : @tl.raltTCL
                            .   raltTCL'    =   @hd.raltTC' : @tl.raltTCL'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can a Expr fail, that is, has a guard which can fail? Indicated by non-emptyness of caseId's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
ATTR Expr [ | | caseFailS USE {`Set.union`} {Set.empty}: UIDS ]

SEM Expr
  | Case        lhs         .   caseFailS   =   @caseFailS
%%]
  | CaseAltFail lhs         .   caseFailS   =   Set.singleton @caseId

