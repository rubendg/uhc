%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer)
ATTR NTPrf [ | | gathCnstrMp USE {`cnstrMpUnion`} {Map.empty}: CHRPredOccCnstrMp ]

SEM Expr
  | IConst CConst Var Con
                loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   @hereCnstrMp
  | App         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @func.gathCnstrMp, @arg.gathCnstrMp]
  | TypeAs      loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, foGathCnstrMp @fo_fitDown, @expr.gathCnstrMp]
  | Let         loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                loc         .   gathCnstrMp         =   ehcOptTrace @lhs.opts "Expr.Let.loc.gathCnstrMp" $ 
                                                        cnstrMpUnions [@hereCnstrMp,@toProveElsewhereCnstrMp,@body.gathCnstrMp]
  | Lam         loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@arg.gathCnstrMp,@body.gathCnstrMp]
%%[[12
  | LamImpl     loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@arg.gathCnstrMp,@body.gathCnstrMp]
%%]]
  | Rec         loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@recExpr.gathCnstrMp]
  | AppTop      loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@expr.gathCnstrMp]
%%]

%%[(10 hmtyinfer)
SEM Expr
  | Sel         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @expr.gathCnstrMp]
  | Rec         loc         .   hereCnstrMp         :=  cnstrMpUnions [foGathCnstrMp @fo_, gathPredLToAssumeCnstrMp @knPrL]

SEM RecExpr
  | Ext Upd     loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @recExpr.gathCnstrMp, @expr.gathCnstrMp]

SEM RecPatExpr
  | Ext         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @recPatExpr.gathCnstrMp, @patExpr.gathCnstrMp]
%%]

%%[(41 hmtyinfer)
SEM PatExpr
  | Con         loc         .   hereCnstrMp         =   foGathCnstrMp @fo_fitP_
                lhs         .   gathCnstrMp         =   @loc.hereCnstrMp

SEM DataFieldPatExpr
  | Con         loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   @loc.hereCnstrMp
%%]

%%[(92 hmtyinfer)
SEM Decl
  | Instance    loc         .   generCnstrMp        =   cnstrMpUnions $ map foGathCnstrMp @foGenerDerivL
%%]

%%[(97 hmtyinfer)
SEM PatExpr
  | Expr        loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @expr.gathCnstrMp]
%%]

%%[(9 hmtyinfer)
SEM Decl
  | Instance    loc         .   (chrCtxtAssumeCnstrMp,chrSuperProveCnstrMp,chrInstAssumeCnstrMp,chrCtxtArgUIDL,chrCtxtArgNmL,chrSuperProveUIDL,chrSuperProveNmL,chrInstArgUID,chrInstNm)
                                                    =   let (u:us) = mkNewUIDL (lc + ls + 1) @lUniq6
                                                            (usc,uss) = splitAt lc us
                                                            lc = length @ctxtPrFixL
                                                            ls = length @supPrTyL
                                                            mka p u = rngLift @range mkAssumeConstraint p u @predScope
                                                            mkp p u = rngLift @range mkProveConstraint  p u @predScope
                                                            (dNm,toAssume,toProve)
                                                               = case @instVariant of
                                                                   InstDefault -> ( @dictSelfNm
                                                                                  , emptyCnstrMp
                                                                                  , emptyCnstrMp
                                                                                  )
                                                                   _           -> ( @dictBuildNm
                                                                                  , cnstrMpFromList $ zipWith mka @ctxtPrFixL            usc
                                                                                  , cnstrMpFromList $ zipWith mkp (map tyPred @supPrTyL) uss
                                                                                  )
                                                        in  ( toAssume, toProve
                                                            , cnstrMpFromList [rngLift @range mkAssumeConstraint' (tyPred @hdPrTyFix) u dNm @predScope]
                                                            , usc, map mkHNm usc
                                                            , uss, map mkHNm uss
                                                            , u, dNm
                                                            )
               lhs          .   gathCnstrMp         =   Map.empty
%%[[9
               loc          .   toProveGathCnstrMp  =   @tyVarMpDeclsL0 `varUpd` @decls.gathCnstrMp
%%][(91 codegen)
               loc          .   (toProveGathCnstrMp,derivAltsPrOcc,derivExtraPrOcc,derivDCL)
                                                    =   case @instVariant of
                                                          InstDeriving _
                                                            | isJust derivDCL
%%[[92
                                                              && not (dgiIsRec @derivDataDGI)
%%]]
                                                              -> ( gathPredLToProveCnstrMp $ foVarMp foDt `varUpd` concat (extraPrOcc : altsPrOcc)
                                                                 , altsPrOcc, extraPrOcc
                                                                 , fromJust derivDCL
                                                                 )
%%[[92
                                                            | not $ null @generForFitsInL
                                                              -> ( cnstrMpUnions [ {- gathPredLToProveCnstrMp $ foVarMp foDt `varUpd` concat (altsPrOcc)
                                                                                 , -} @tyVarMpDeclsL0 `varUpd` @generCnstrMp
                                                                                 ]
                                                                 , [], []
                                                                 , emptyDerivCls
                                                                 )
%%]]
                                                            | otherwise
                                                              -> (emptyCnstrMp,[],[],emptyDerivCls)
                                                            where ([dataTy],dataAltTy) = appUnArr $ dgiDataTy @derivDataDGI
                                                                  alts = tyRecExts2 dataAltTy
                                                                  altsPrOcc
                                                                       = [ [ rngLift @range mkPredOccRng (Pred_Class (appTopApp [@derivHdPrTyCon,t])) (mkPrIdCHR u2) @predScope
                                                                           | ((_,t),u2) <- zip a1 (mkNewUIDL (length a1) u1)
                                                                           ]
                                                                         | ((_,a1),u1) <- zip alts (mkNewLevUIDL (length alts) @lUniq_95_altsPrOcc)
                                                                         ]
                                                                  extraPrOcc
                                                                       = [ rngLift @range mkPredOccRng (Pred_Class (dccMkTy cx)) (mkPrIdCHR u) @predScope
                                                                         | (cx,u) <- zip cxl (mkNewUIDL (length cxl) @lUniq_95_extraPrOcc)
                                                                         ]
                                                                       where cxl = maybe [] dclExtraCtxt derivDCL
                                                                  foDt = fitsIn unifyFIOpts @fe @lUniq_95_fitsIn_dataTy (emptyVarMp :: VarMp) dataTy @derivHdDataTy
                                                                  derivDCL = Map.lookup @instClsNm @derivMp
                                                          _ -> (@tyVarMpDeclsL0 {- 1 -} `varUpd` @decls.gathCnstrMp,[],[],emptyDerivCls)
                loc         .   lUniq_95_altsPrOcc  :   UNIQUEREF gUniq
                loc         .   lUniq_95_extraPrOcc :   UNIQUEREF gUniq
                loc         .   lUniq_95_fitsIn_dataTy
                                                    :   UNIQUEREF gUniq
%%]]
                loc         .   lUniq6              :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Proving (predicates) via CHR's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer) hs
-- | behavior configuration of simplify
data SimplifyHow
  = SimplifyHow_Canonicalize            -- canonicalize predicates
  deriving Eq
%%]

%%[(9 hmtyinfer) hs
data SimplifyState
  = SimplifyState
      { simpToProveHereCnstrMp          :: !CHRPredOccCnstrMp                               -- new constraints to prove
      , simpAllCnstrMp                  :: !CHRPredOccCnstrMp                               -- all constraints to prove, including previous
      , simpRemCnstrTraceMp             :: !CHRPredOccCnstrTraceMp                          -- remaining to be proven, as Assume's
      , simpRemOccL                     :: ![CHRIntermediateUntilAssume]                    -- same, but only occurrences (as list), with original trace mp split up per pred
      , simpCannotCnstrTraceMp          :: !CHRPredOccCnstrTraceMp                          -- cannot be proven
      , simpVarMp                       :: !VarMp                                           -- additional substitution
      , simpEvidMp                      :: !CHRPredOccEvidMp                                -- map from constraint/pred occurrence to evidence
      , simpEnv                         :: !FIIn
      , simpRes                         :: !(SimplifyResult CHRPredOcc RedHowAnnotation Guard VarMp)                                -- simplification work done at a previous call
      , simpErrs                        :: ![Err]                                           -- errors
      }

emptySimplifyState :: SimplifyState
emptySimplifyState = SimplifyState Map.empty Map.empty Map.empty [] Map.empty emptyVarMp Map.empty (emptyFI :: FIIn) emptySimplifyResult []

simplify'
  :: [SimplifyHow]
     -> ScopedPredStore                                                                     -- available CHR rules
     -> ClassDefaultGam                                                                     -- environment/gam for defaulting
     -> Heuristic CHRPredOcc RedHowAnnotation                                               -- graph reduction heuristic
     -> ([CHRIntermediateUntilAssume] -> ([CHRIntermediateUntilAssume],[CHRIntermediateUntilAssume]))   -- partition into ambiguous predicates (and others), for defaulting
     -> CHRPredOccCnstrMp                                                                   -- constraints already proven a previous call
     -> State SimplifyState ()
simplify' simplifyHow chrStore clDfGam heur partitionUnresolved2AmbigAndOthers toProveHereCnstrMpPrev
  = do { s <- get

       ; let -- unique seeds 
             (_,u1,u2,u3) = mkNewLevUID3 $ fiUniq origEnv

             -- remember for later
             origEnv = simpEnv s
         
       -- canonicalize predicate occurrences (expand type signatures, record fields in same order)
       ; when (SimplifyHow_Canonicalize `elem` simplifyHow)
              (do { s <- get
                  ; let (pr,mp)
                          = Map.foldrWithKey (\p c (cm,m)
                                               -> let (p',m') = canon s p
                                                  in  (Map.insertWith (++) p' c cm, m' `varUpd` m)
                                            )
                                            (Map.empty,emptyVarMp :: VarMp) (simpToProveHereCnstrMp s) 
                  ; put (s {simpToProveHereCnstrMp = pr, simpVarMp = mp `varUpd` simpVarMp s})
                  })

       -- adapt env to inhibit bindings for variables freely occurring in predicates, these are fixed (apart from improving substitutions, when resolving defaulting)
       ; modify (\s -> let e = simpEnv s
                           o = fiFIOpts e
                       in  s {simpEnv = e {fiFIOpts = o {fioDontBind = fixedFtv (simpToProveHereCnstrMp s), fioBindCategs = TyVarCateg_Meta : fioBindCategs o}}}
                )
       
       -- get base result, for backtracking to when restarting for defaulting
       ; s <- get
       ; let prevSimplifyRes = simpRes s
       
       -- 1st simplification run
       ; (cannotResCnstrTraceMp,chrSolveAssumablePrOccL) <- fullSimp u1 toProveHereCnstrMpPrev prevSimplifyRes
       ; modify (\s -> s {simpCannotCnstrTraceMp = cannotResCnstrTraceMp, simpRemOccL = chrSolveAssumablePrOccL})
       
       -- defaulting is done here very crudely, find defaulting candidates, apply the improving substitution, and restart. TBD: this is a hack, do this better, probably when improving subst are done right.
       ; s <- get
       ; let (chrSolveAmbigPrOccL,chrSolveAssumablePrOccL)
               = partitionUnresolved2AmbigAndOthers (simpRemOccL s)
       ; when ( -- Debug.tr "chrSolveAmbigPrOccL" (ppCommas (simpRemOccL s) >-< ppCommas chrSolveAmbigPrOccL >-< ppCommas chrSolveAssumablePrOccL) $
                not (null chrSolveAmbigPrOccL))
              (do { let (dfltPrOccL,dfltTyVarMp) = foldr cmb ([],emptyVarMp) chrSolveAmbigPrOccL
                          where cmb :: (CHRPredOcc,x) -> ([CHRPredOcc],VarMp) -> ([CHRPredOcc],VarMp)
                                cmb (o,_) r@(os,m) = maybe r (\m' -> (o:os,m' `varUpd` m)) $ clDfGamLookupDefault (origEnv {fiVarMp = m `varUpd` fiVarMp (simpEnv s)}) (cpoPr o) clDfGam
                  ; when ( -- Debug.tr "dfltPrOccL" (ppCommas (simpRemOccL s) >-< ppCommas dfltPrOccL >-< dfltTyVarMp) $
                           not (null dfltPrOccL))
                         -- when a match is found, apply the substitution and kick off proving again
                         (do { modify (\s -> s {simpToProveHereCnstrMp = dfltTyVarMp `varUpd` simpToProveHereCnstrMp s, simpVarMp = dfltTyVarMp `varUpd` simpVarMp s})
                             ; (cannotResCnstrTraceMp,chrSolveAssumablePrOccL) <- fullSimp u1 toProveHereCnstrMpPrev prevSimplifyRes
                             ; modify (\s -> s {simpCannotCnstrTraceMp = cannotResCnstrTraceMp, simpRemOccL = chrSolveAssumablePrOccL})
                             })
                  })
       
       -- (possibly) 2nd simplification run, to deal with unproven constraints which can be assumed or defaulted
       ; s <- get
       ; if   not (null (simpRemOccL s))
         then -- if not all could be proven, assumptions have to be made: clean up, prove again with additional assumptions
              do { s <- get
                 ; let -- remember for later use
                       chrSimplifyResult = simpRes s

                       -- prune the redgraph, remove that which depends on unresolved predicates
                       redGraphPruned
                         = redPruneReductionsUntil (map fst (simpRemOccL s))
                                                   (let m = Set.map cnstrPred $ Map.keysSet (simpToProveHereCnstrMp s) in \p -> Set.member p m)
                                                   (simpresRedGraph chrSimplifyResult)
                       
                 ; modify (\s -> s {simpRes = chrSimplifyResult {simpresRedGraph = redGraphPruned, simpresRedGraphs = ("simplify pruned",redGraphPruned) : simpresRedGraphs chrSimplifyResult}})

                 -- (2nd time) RedGraph to Evidence etc
                 ; (_,chrSolveAssumablePrOccL) <- basicSimpRedGraph (simpAllCnstrMp s)
                 ; modify (\s -> s {simpRemOccL = chrSolveAssumablePrOccL})
                 
                 -- convert to Assume constraints
                 ; s <- get
                 ; let (chrSolveRemCnstrTraceMp,chrSolveEvidMp)
                         = patchUnresolvedWithAssumption ((simpEnv s) {fiUniq = u3}) (simpRemOccL s) (simpresRedGraph chrSimplifyResult) (simpEvidMp s)
                 ; modify (\s -> s {simpRemCnstrTraceMp = chrSolveRemCnstrTraceMp, simpEvidMp = chrSolveEvidMp})
                 }
         else modify (\s -> s {simpRemCnstrTraceMp = Map.empty, simpRemOccL = []})

       ; return ()
       }
  where {-
        canon s (Prove p) = (Prove $ p {cpoPr = p'}, m)
                          where (p',m) = predCanonic (simpEnv s) $ cpoPr p
        canon s  c        = (c, emptyVarMp)
        -}
        canon s c
          = case cnstrReducablePart c of
              Just (_,p,mkc) -> (mkc $ p {cpoPr = p'}, m)
                             where (p',m) = predCanonic (emptyTyBetaRedEnv {tbredFI=simpEnv s}) $ cpoPr p
              _              -> (c, emptyVarMp)
        
        -- basic simplification of reduction graph
        basicSimpRedGraph chrSolveAllCnstrMp
          = do { s <- get
               ; let -- RedGraph to Evidence
                     ((chrSolveRemCnstrTraceMp,chrSolveEvidMp,errs),chrSimplifyResult2)
                       = chrSimplifyRedGraphToEvidence heur chrSolveAllCnstrMp (simpRes s)
        
                     -- split unresolved into those who can be resolved by assuming them (via qualified types) and the others
                     (chrSolveAssumablePrOccL,cannotResCnstrTraceMp)
                       = partitionUnresolved2AssumableAndOthers chrSolveRemCnstrTraceMp
                     -- TBD: propagation of unresolved traces for error reporting
                     -- cannotResCnstrMp   = cnstrTraceMpElimTrace cannotResCnstrTraceMp
                     -- chrSolveRemCnstrMp = cnstrTraceMpElimTrace chrSolveRemCnstrTraceMp
        
               ; put (s {simpRemCnstrTraceMp = chrSolveRemCnstrTraceMp, simpEvidMp = chrSolveEvidMp, simpErrs = errs, simpRes = chrSimplifyResult2})
               ; return (cannotResCnstrTraceMp,chrSolveAssumablePrOccL)
               }

        -- full simplification
        fullSimp u toProveHereCnstrMpPrev chrSimplifyResult
          = do { s <- get
               ; let -- simplification, to RedGraph
                     (chrSolveAllCnstrMp,chrSimplifyResult1)
                       = chrSimplifySolveToRedGraph ((simpEnv s) {fiUniq = u}) chrStore toProveHereCnstrMpPrev (simpToProveHereCnstrMp s) chrSimplifyResult

               ; put (s {simpRes = chrSimplifyResult1, simpAllCnstrMp = chrSolveAllCnstrMp})
               
               -- RedGraph to Evidence etc
               ; basicSimpRedGraph chrSolveAllCnstrMp
               }
%%]

%%[(9 hmtyinfer) hs
simplify
  :: [SimplifyHow]                                                                          -- config
     -> FIIn                                                                                -- environment
     -> ScopedPredStore                                                                     -- available CHR rules
     -> ClassDefaultGam                                                                     -- environment/gam for defaulting
     -> Heuristic CHRPredOcc RedHowAnnotation                                               -- graph reduction heuristic
     -> ([CHRIntermediateUntilAssume] -> ([CHRIntermediateUntilAssume],[CHRIntermediateUntilAssume]))   -- partition into ambiguous predicates (and others), for defaulting
     -> CHRPredOccCnstrMp                                                                   -- constraints already proven a previous call
     -> CHRPredOccCnstrMp                                                                   -- constraints to prove
     -> SimplifyResult CHRPredOcc RedHowAnnotation Guard VarMp                              -- simplification work done at a previous call
     -> ( CHRPredOccCnstrMp                                                                 -- canonicalized to be proven constraints
        , CHRPredOccCnstrTraceMp                                                            -- remaining to be proven, as Assume's
        , CHRPredOccCnstrTraceMp                                                            -- cannot be proven
        , VarMp                                                                             -- additional substitution found during proving & simplification
        , [Err]                                                                             -- errors
        , SimplifyResult CHRPredOcc RedHowAnnotation Guard VarMp                            -- simplification work, for a next call
        , CHRPredOccEvidMp                                                                  -- map from constraint/pred occurrence to evidence
%%[[(9 codegen)
        , EvidKeyToCBindMap                                                                 -- map from occurrence to binding, globally
        , PredScopeToCBindMap                                                               -- map from predscope to binding, per predscope opening/intro
        , EvidKeyToCExprMap                                                                 -- map from occurrence to expr + additional nesting info, for debug only
%%]]
%%[[(9 codegen tycore)
        , E2C.EvidKeyToValBindMap                                                           -- TyCore variants from the above 3 results
        , E2C.PredScopeToValBindMap
        , E2C.EvidKeyToExprMap                                                              -- for debug only
%%]]
        )
simplify simplifyHow env chrStore clDfGam heur partitionUnresolved2AmbigAndOthers toProveHereCnstrMpPrev toProveHereCnstrMp prevRes
  = {- Debug.tr "simplify"
      (   (if toProveHereCnstrMpCanon == toProveHereCnstrMpCanon' then empty else pp "toProveHereCnstrMpCanon wrong")
      >-< (if canonVarMp == canonVarMp' then empty else pp "canonVarMp wrong")
      >-< (if cannotResCnstrMp1 == cannotResCnstrMp1' then empty else pp "cannotResCnstrMp1 wrong")
      >-< (if chrSolveRemCnstrMp3 == chrSolveRemCnstrMp3' then empty else pp "chrSolveRemCnstrMp3 wrong" >-< show chrSolveRemCnstrMp3 >-< show chrSolveRemCnstrMp3')
      -- >-< (if chrSolveAssumablePrOccL3 == chrSolveAssumablePrOccL3' then empty else pp "chrSolveAssumablePrOccL3 wrong" >-< ppCommas chrSolveAssumablePrOccL3 >-< ppCommas chrSolveAssumablePrOccL3')
      ) $
    -}
    ( toProveHereCnstrMpCanon
    , chrSolveRemCnstrMp3, cannotResCnstrTraceMp
    , canonVarMp
    , firstNotEmpty
        [ chrSolveErrs2
%%[[(9 codegen)
        , overlapErrs
%%]]
        ]
    , chrSimplifyResult4
        { simpresRemPredL = map fst chrSolveAssumablePrOccL3
        }
    , chrSolveEvidMp2
%%[[(9 codegen)
    , chrSolveEvidBindMp, chrSolveScopeBindMp
    , chrSolveEvidCoreMp        -- for debug only
%%]]
%%[[(9 codegen tycore)
    -- TyCore variant
    , chrSolveEvidBindMpTC, chrSolveScopeBindMpTC
    , chrSolveEvidCoreMpTC      -- for debug only
%%]]
    )
  where s = execState (simplify' simplifyHow chrStore clDfGam heur partitionUnresolved2AmbigAndOthers toProveHereCnstrMpPrev)
                      (emptySimplifyState {simpEnv = env {fiUniq = u1}, simpToProveHereCnstrMp = toProveHereCnstrMp, simpRes = prevRes})
        env'                        =   simpEnv s
        chrSimplifyResult4          =   simpRes s
        chrSolveAssumablePrOccL3    =   simpRemOccL s
        chrSolveRemCnstrMp3         =   simpRemCnstrTraceMp s
        chrSolveEvidMp2             =   simpEvidMp s
        chrSolveErrs2               =   simpErrs s
        toProveHereCnstrMpCanon     =   simpToProveHereCnstrMp s
        canonVarMp                  =   simpVarMp s
        cannotResCnstrTraceMp       =   simpCannotCnstrTraceMp s
  
        -- some unique seeds
        (_,u1,u2,u3) = mkNewLevUID3 $ fiUniq env
        
%%[[(9 codegen)
        -- (1) compute code (Core) for dictionaries/witness, (2) get the overlapping instances
        (chrSolveEvidCoreMp,overlapEvids)
          = evidMpToCore (env' {fiUniq = u3}) chrSolveEvidMp2
        
        -- get the bindings which must be introduced
        (chrSolveEvidBindMp,chrSolveScopeBindMp)
          = evidKeyCoreMpToBinds env' chrSolveEvidCoreMp
        
        -- overlapping errors; 20120209: is empty, detection done earlier
        -- overlapErrs = if null overlapEvids then [] else [rngLift range Err_OverlapPreds [ (cpoPr $ overlapevidPredOcc a,map pp $ overlapevidInfos a) | a <- overlapEvids]]
        overlapErrs = []
%%]]
        -- TyCore variant
%%[[(9 codegen tycore)
        (chrSolveEvidCoreMpTC,overlapEvidsTC)
          = E2C.evidMpToCore (env' {fiUniq = u3}) chrSolveEvidMp2
        (chrSolveEvidBindMpTC,chrSolveScopeBindMpTC)
          = E2C.evidKeyCoreMpToBinds chrSolveEvidCoreMpTC
%%]]
%%[[9
        range = emptyRange
%%][99
        range = feRange $ fiEnv env
%%]]
        -- debugging info
        -- dbgp = ppParensCommas $ Map.keys toProveHereCnstrMpCanon
        -- dbg m= id -- Debug.tr m dbgp
        
%%]

%%[(9 hmtyinfer) hs
fixedFtv mp = varFreeSet $ map cnstrPred $ Map.keys mp

debugInfo chrSimplifyResult
  = (s,rg,chrSolveStateDoneConstraints s,chrSolveStateTrace s,redAlts,redTrees,simpresRemPredL chrSimplifyResult)
  where s  = simpresSolveState chrSimplifyResult
        rg = simpresRedGraph chrSimplifyResult
        redAlts  = simpresRedAlts   chrSimplifyResult
        redTrees = simpresRedTrees  chrSimplifyResult

%%]

%%[(9 hmtyinfer)
SEM AGItf
  | AGItf       loc         .   chrProveFIIn        =   @chrFIIn {fiVarMp = @expr.tyVarMp}
                            .   toProveCnstrMp      =   @expr.tyVarMp `varUpd` @expr.gathCnstrMp
                            .   toProveHereCnstrMp  =   @toProveCnstrMp
                            .   (_,chrSolveMainRemCnstrMp,_,chrSolveSimpTyVarMp,chrSolveMainErrs,chrSimplifyResult,_
%%[[(9 codegen)
                                ,chrSolveMainEvidBindMp,chrSolveMainScopeBindMp,chrSolveMainEvidCoreMp
%%]]
%%[[(9 codegen tycore)
                                ,chrSolveMainEvidBindMpTC,chrSolveMainScopeBindMpTC,chrSolveMainEvidCoreMpTC
%%]]
                                )
                                                    =   ehcOptTrace @lhs.opts "AGItf.simplify" $ 
                                                        simplify [SimplifyHow_Canonicalize] (@chrProveFIIn {fiUniq = @lUniq_9_simplify}) @chrStore @clDfGam (heurScopedEHC @chrProveFIIn) (\x -> (x,[])) Map.empty @toProveHereCnstrMp emptySimplifyResult
                            .   (chrSolveMainState,chrSolveMainRedGraph,chrSolveMainDoneConstraints,chrSolveMainTrace,_,_,_)
                                                    =   debugInfo @chrSimplifyResult
                            .   cannotProveCnstrMp  =   @chrSolveMainRemCnstrMp
                loc         .   lUniq_9_simplify    :   UNIQUEREF gUniq
%%]

%%[(9 hmtyinfer)
SEM Expr
  | Let         loc         .   chrProveFIIn        =   @chrFIIn {fiVarMp = @tyVarMpDeclsL0}
                            .   toProveCnstrMp      =   @tyVarMpDeclsL0 {- 1 -} `varUpd` @decls.gathCnstrMp
                            .   (toProveHereCnstrMp,toProveElsewhereCnstrMp)
                                                    =   let (here,there) = Map.partitionWithKey (\k _ -> isLetProveCandidate @noLetQuantTyVarIdS $ cnstrPred k) @toProveCnstrMp
                                                        in  (here, predOccCnstrMpLiftScope @predScope there)
                            
                            --  1st context simplification
                            .   (toProveHereCnstrMpCanon,chrSolve1RemCnstrMp,cannotRes1CnstrMp,chrSolve1SimpTyVarMp,chrSolve1Errs,chrSimplifyResult1,chrSolve1EvidMp
%%[[(9 codegen)
                                ,chrSolve1EvidBindMp  ,chrSolve1ScopeBindMp  ,chrSolve1EvidCoreMp
%%]]
%%[[(9 codegen tycore)
                                ,chrSolve1EvidBindMpTC,chrSolve1ScopeBindMpTC,chrSolve1EvidCoreMpTC
%%]]
                                )
                                                    =   ehcOptTrace @lhs.opts "Expr.Let.simplify1" $ 
                                                        simplify [SimplifyHow_Canonicalize] (@chrProveFIIn {fiUniq = @lUniq5}) @lhs.chrStore @lhs.clDfGam (heurScopedEHC @chrProveFIIn) @doPredAmbigSplitForSimplify Map.empty @toProveHereCnstrMp emptySimplifyResult
                            .   (chrSolve1State,chrSolve1RedGraph,chrSolve1DoneConstraints,chrSolve1Trace,_,_,chrSolve1RemPrOccL)
                                                    =   debugInfo @chrSimplifyResult1

                            .   (toAssumeNeverCnstrMp,_)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveFailure @noLetQuantTyVarIdS $ cnstrPred k) @chrSolve1RemCnstrMp
                            .   cannotProveCnstrMp  =   cnstrMpUnions [@toAssumeNeverCnstrMp,@cannotRes1CnstrMp]

                            
                            --  2nd (additional) context simplification, only necessary when additional assumptions are injected, i.e. those quantified over
                loc         .   secondProofIsNeeded =   not (Map.null @quantCnstrMp)
                            .   (_,chrSolve2RemCnstrMp,_,chrSolve2SimpTyVarMp,chrSolve2Errs,chrSimplifyResult2,_
%%[[(9 codegen)
                                ,chrSolve2EvidBindMp  ,chrSolve2ScopeBindMp  ,chrSolve2EvidCoreMp
%%]]
%%[[(9 codegen tycore)
                                ,chrSolve2EvidBindMpTC,chrSolve2ScopeBindMpTC,chrSolve2EvidCoreMpTC
%%]]
                                )
                                                    =   if @secondProofIsNeeded
                                                        then ehcOptTrace @lhs.opts "Expr.Let.simplify2"
                                                             $ simplify [] (@chrProveFIIn {fiUniq = @lUniq4}) @lhs.chrStore @lhs.clDfGam (heurScopedEHC @chrProveFIIn) ((,) []) @toProveHereCnstrMpCanon @quantCnstrMp
                                                             $ simplifyResultResetForAdditionalWork @chrSimplifyResult1
                                                        else ( emptyCnstrMp, @chrSolve1RemCnstrMp, emptyCnstrMp, emptyVarMp, [], @chrSimplifyResult1, @chrSolve1EvidMp
%%[[(9 codegen)
                                                             , @chrSolve1EvidBindMp  , @chrSolve1ScopeBindMp  , @chrSolve1EvidCoreMp
%%]]
%%[[(9 codegen tycore)
                                                             , @chrSolve1EvidBindMpTC, @chrSolve1ScopeBindMpTC, @chrSolve1EvidCoreMpTC
%%]]
                                                             )
                            .   (chrSolve2State,chrSolve2RedGraph,chrSolve2DoneConstraints,chrSolve2Trace,chrSolve2RedAlts,chrSolve2RedTrees,_)
                                                    =   debugInfo @chrSimplifyResult2
                loc         .   lUniq4              :   UNIQUEREF gUniq
                loc         .   lUniq5              :   UNIQUEREF gUniq
%%]

%%[(9 hmtyinfer)
SEM Decl
  | Instance    loc         .   chrProveFIIn        =   @chrFIIn {fiVarMp = @tyVarMpDeclsL0}
                            .   toProveDeclsCnstrMp =   cnstrMpUnions [@chrInstAssumeCnstrMp, @chrCtxtAssumeCnstrMp, @toProveGathCnstrMp]
                            .   (_,chrSolveDeclsRemCnstrMp,cannotResDeclsCnstrMp,chrSolveSimpTyVarMp,chrSolveDeclsErrs,chrDeclsSimplifyResult,_
%%[[(9 codegen)
                                ,chrSolveDeclsEvidBindMp,chrSolveDeclsScopeBindMp,_
%%]]
%%[[(9 codegen tycore)
                                ,chrSolveDeclsEvidBindMpTC,chrSolveDeclsScopeBindMpTC,_
%%]]
                                )
                                                    =   ehcOptTrace @lhs.opts "Decl.Instance.simplify1" $ 
                                                        simplify [SimplifyHow_Canonicalize] (@chrProveFIIn {fiUniq = @lUniq7}) @lhs.chrStore @lhs.clDfGam (heurScopedEHC @chrProveFIIn) ((,) []) Map.empty @toProveDeclsCnstrMp emptySimplifyResult
                            .   (chrSolveDeclsState,chrSolveDeclsRedGraph,chrSolveDeclsDoneConstraints,chrSolveDeclsTrace,_,_,_)
                                                    =   debugInfo @chrDeclsSimplifyResult

                            .   toProveSuperCnstrMp =   cnstrMpUnions [@chrCtxtAssumeCnstrMp,@chrSuperProveCnstrMp]
                            .   (_,chrSolveSuperRemCnstrMp,cannotResSuperCnstrMp,chrSolveSuperSimpTyVarMp,chrSolveSuperErrs,chrSuperSimplifyResult,_
%%[[(9 codegen)
                                ,chrSolveSuperEvidBindMp,chrSolveSuperScopeBindMp,_
%%]]
%%[[(9 codegen tycore)
                                ,chrSolveSuperEvidBindMpTC,chrSolveSuperScopeBindMpTC,_
%%]]
                                )
                                                    =   ehcOptTrace @lhs.opts "Decl.Instance.simplify2" $ 
                                                        simplify [SimplifyHow_Canonicalize] (@chrProveFIIn {fiUniq = @lUniq5}) @lhs.chrStore @lhs.clDfGam (heurScopedEHC @chrProveFIIn) ((,) []) Map.empty @toProveSuperCnstrMp emptySimplifyResult
                            .   (chrSolveSuperState,chrSolveSuperRedGraph,chrSolveSuperDoneConstraints,chrSolveSuperTrace,_,_,_)
                                                    =   debugInfo @chrSuperSimplifyResult

                            .   toAssumeNeverCnstrMp
                                                    =   cnstrMpUnions [@chrSolveDeclsRemCnstrMp,@chrSolveSuperRemCnstrMp]
                            .   cannotProveCnstrMp  =   cnstrMpUnions [@toAssumeNeverCnstrMp,@cannotResDeclsCnstrMp,@cannotResSuperCnstrMp]
                loc         .   lUniq5              :   UNIQUEREF gUniq
                loc         .   lUniq7              :   UNIQUEREF gUniq
%%]
                            .   (toAssumeNeverCnstrMp,_)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveFailure Set.empty $ cnstrPred k)
                                                        $ cnstrMpUnions [@chrSolveDeclsRemCnstrMp,@chrSolveSuperRemCnstrMp]

Interaction with generalisation:
Construct the list of predicates over which must be generalised from the ones failed to prove in the 1st context simplification.

%%[(9 hmtyinfer)
SEM Expr
  | Let         loc         --  predicate occurrences over which we quantify
                            .   toQuantOverPrOccL   =   [ rngLift @range mkPredOccRng (cpoPr o) (mkPrIdCHR $ vunmId i) sc
                                                        | (Assume o,[(RedHow_Assumption i sc, _)])
                                                            <- Map.toList $ @chrSolve1RemCnstrMp `Map.difference` @cannotProveCnstrMp
                                                        ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional prove requirements + assume introductions yielded by generalization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer)
SEM Expr
  | Let         loc         .   (quantCnstrMp, coeArgIdMp)
                                                    =   let mk u nm tmpo
                                                              = (cnstrMpFromList ass `cnstrMpUnion` cnstrMpUnions (map cnstrMpFromList prvs), concat coeArgIds)
                                                              where assSc = maybe @predScope id $ gamLookup nm @decls.scopeGam
                                                                    (ass,prvs,coeArgIds)
                                                                      = unzip3 [ ( rngLift @range mkAssumeConstraint pr (poId po) assSc
                                                                                 , zipWith (\u i -> rngLift @range mkProveConstraint pr u (ipoScope i)) ups ipos
                                                                                 , zipWith (\u i -> (ipoId i,u)) ups ipos
                                                                                 )
                                                                               | ((po,ipos),u') <- zip impls $ mkNewLevUIDL (length impls) u
                                                                               , let ups = mkNewLevUIDL (length ipos) u'
                                                                                     pr  = poPr po -- @bodyVarMp2 `varUpd` poPr po
                                                                               ]
                                                                    impls = tmpoImplsPrvReq tmpo
                                                            tmpos = gamToAssocL @tqoGam
                                                            (quantCnstrMps, coeArgIds) = unzip $ zipWith (\(nm,tmpo) u -> mk u nm tmpo) tmpos $ mkNewLevUIDL (length tmpos) @lUniq6
                                                        in  ( cnstrMpUnions quantCnstrMps
                                                            , foldr (\(occ,arg) m -> Map.insertWith (++) occ [arg] m) Map.empty $ concat coeArgIds
                                                            )
                            .   prvArgCSubst        =   let mk a = (acoreNmHole a)
                                                        in  acoreCSubstFromUidImplsL [ (occ, ([acoreCoeAppN $ map mk args], [])) | (occ,args) <- Map.toList @coeArgIdMp ]
                loc         .   lUniq6              :   UNIQUEREF gUniq
%%]

TyCore variant/clone:

%%[(9 hmtyinfer tycore)
SEM Expr
  | Let         loc         .   prvArgTCSubst       =   let mk a = (mkHNm a)
                                                        in  acoreCSubstFromUidImplsL [ (occ, ([acoreCoeAppNbyName $ map mk args], [])) | (occ,args) <- Map.toList @coeArgIdMp ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Propagation of bindings resulting from assumptions downwards
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen hmtyinfer)
ATTR NTPrf [ chrEvidBindMp: EvidKeyToCBindMap   chrScopeBindMp: PredScopeToCBindMap | | ]

SEM AGItf
  | AGItf       loc         .   chrEvidBindMp       =   @chrSolveMainEvidBindMp

SEM Decl
  | Instance    loc         .   chrEvidBindMp       =   @chrSolveDeclsEvidBindMp `evidKeyToBindMapUnion` @lhs.chrEvidBindMp
                            .   chrScopeBindMp      =   @chrSolveDeclsScopeBindMp `predScopeToBindMapUnion` @lhs.chrScopeBindMp

SEM Expr
  | Let         loc         .   chrSolveEvidBindMp  =   @chrSolve2EvidBindMp
                            .   chrEvidBindMp       =   ehcOptTrace @lhs.opts "Expr.Let.loc.chrEvidBindMp" $ 
                                                        @chrSolveEvidBindMp `evidKeyToBindMapUnion` @lhs.chrEvidBindMp
                            .   chrSolveScopeBindMp =   @chrSolve2ScopeBindMp
                            .   chrLetScopeBindMp   =   ehcOptTrace @lhs.opts "Expr.Let.loc.chrLetScopeBindMp" $ 
                                                        @chrSolveScopeBindMp `predScopeToBindMapUnion` @lhs.chrScopeBindMp
%%]

TyCore variant/clone:

%%[(9 codegen tycore hmtyinfer)
ATTR NTPrf [ chrEvidBindMpTC: {E2C.EvidKeyToValBindMap}   chrScopeBindMpTC: {E2C.PredScopeToValBindMap} | | ]

SEM AGItf
  | AGItf       loc         .   chrEvidBindMpTC     =   @chrSolveMainEvidBindMpTC

SEM Decl
  | Instance    loc         .   chrEvidBindMpTC     =   @chrSolveDeclsEvidBindMpTC `E2C.evidKeyToValBindMapUnion` @lhs.chrEvidBindMpTC
                            .   chrScopeBindMpTC    =   @chrSolveDeclsScopeBindMpTC `E2C.predScopeToValBindMapUnion` @lhs.chrScopeBindMpTC

SEM Expr
  | Let         loc         .   chrSolveEvidBindMpTC=   @chrSolve2EvidBindMpTC
                            .   chrEvidBindMpTC     =   @chrSolveEvidBindMpTC `E2C.evidKeyToValBindMapUnion` @lhs.chrEvidBindMpTC
                            .   chrSolveScopeBindMpTC=  @chrSolve2ScopeBindMpTC
                            .   chrLetScopeBindMpTC =   @chrSolveScopeBindMpTC `E2C.predScopeToValBindMapUnion` @lhs.chrScopeBindMpTC
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings depending on scope
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen hmtyinfer) hs
mkScopeBindings :: Bool -> PredScope -> PredScopeToCBindMap -> ([CBind],PredScopeToCBindMap)
mkScopeBindings alsoOuter sc mp
  = (concatMap f scs,foldr Map.delete mp scs)
  where f sc = Map.findWithDefault [] sc mp
        scs  = [sc] ++ (if alsoOuter then pscpParents sc else [])
%%]

%%[(9 codegen hmtyinfer)
SEM AGItf
  | AGItf       loc         .   (chrScopeMainBindL,chrScopeBindMp)
                                                    =   mkScopeBindings True @predScope @chrSolveMainScopeBindMp

SEM Decl
  | Instance    loc         .   (chrScopeSuperBindL,_)
                                                    =   mkScopeBindings True @predScope @chrSolveSuperScopeBindMp
                            .   (chrScopeDeclsBindL,_)
                                                    =   mkScopeBindings True @predScope @chrSolveDeclsScopeBindMp
  | Val         loc         .   (chrScopeValBindL,chrScopeBindMp)
                                                    =   mkScopeBindings False @predScope @lhs.chrScopeBindMp

SEM Expr
  | Let         loc         .   (chrScopeBindL,chrScopeBindMp)
                                                    =   mkScopeBindings True @predScope @chrLetScopeBindMp
  | AppTop Rec Lam
%%[[12
    LamImpl
%%]]
                loc         .   (chrScopeBindL,chrScopeBindMp)
                                                    =   mkScopeBindings False @predScope @lhs.chrScopeBindMp
%%]

TyCore variant/clone:

%%[(9 codegen tycore hmtyinfer) hs
mkScopeValBinds :: Bool -> PredScope -> E2C.PredScopeToValBindMap -> ([C.ValBind],E2C.PredScopeToValBindMap)
mkScopeValBinds alsoOuter sc mp
  = (concatMap f scs,foldr Map.delete mp scs)
  where f sc = Map.findWithDefault [] sc mp
        scs  = [sc] ++ (if alsoOuter then pscpParents sc else [])
%%]

%%[(9 codegen tycore hmtyinfer)
SEM AGItf
  | AGItf       loc         .   (chrScopeMainBindLTC,chrScopeBindMpTC)
                                                    =   mkScopeValBinds True @predScope @chrSolveMainScopeBindMpTC

SEM Decl
  | Instance    loc         .   (chrScopeSuperBindLTC,_)
                                                    =   mkScopeValBinds True @predScope @chrSolveSuperScopeBindMpTC
                            .   (chrScopeDeclsBindLTC,_)
                                                    =   mkScopeValBinds True @predScope @chrSolveDeclsScopeBindMpTC
  | Val         loc         .   (chrScopeValBindLTC,chrScopeBindMpTC)
                                                    =   mkScopeValBinds False @predScope @lhs.chrScopeBindMpTC

SEM Expr
  | Let         loc         .   (chrScopeBindLTC,chrScopeBindMpTC)
                                                    =   mkScopeValBinds True @predScope @chrLetScopeBindMpTC
  | AppTop Rec Lam
%%[[12
    LamImpl
%%]]
                loc         .   (chrScopeBindLTC,chrScopeBindMpTC)
                                                    =   mkScopeValBinds False @predScope @lhs.chrScopeBindMpTC
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings for assumed preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen hmtyinfer) hs
mkAssumeBindings :: [UID] -> EvidKeyToCBindMap -> [CBind]
mkAssumeBindings ids mp
  = concat [ maybe [] id $ Map.lookup i mp | i <- ids ]
%%]

%%[(9 codegen tycore hmtyinfer) hs
mkAssumeValBinds :: [UID] -> E2C.EvidKeyToValBindMap -> [C.ValBind]
mkAssumeValBinds ids mp
  = concat [ maybe [] id $ Map.lookup i mp | i <- ids ]
%%]

%%[(9 codegen hmtyinfer)
SEM Decl
  | Instance    loc         .   chrAssumeSuperBindL     =   mkAssumeBindings @chrCtxtArgUIDL @chrSolveSuperEvidBindMp
                            .   chrAssumeDeclsInstBindL =   mkAssumeBindings [@chrInstArgUID] @chrEvidBindMp
                            .   chrAssumeDeclsCtxtBindL =   mkAssumeBindings @chrCtxtArgUIDL @chrEvidBindMp

SEM Expr
  | AppTop Rec Lam Let
%%[[12
    LamImpl
%%]]
                loc         .   chrAssumeBindL      =   mkAssumeBindings (map poiId @poiL) @lhs.chrEvidBindMp
%%[[(9 tycore)
                loc         .   chrAssumeBindLTC    =   mkAssumeValBinds (map poiId @poiL) @lhs.chrEvidBindMpTC -- for TyCore
%%]]
%%]
